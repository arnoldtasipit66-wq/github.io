<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pinoy Pool</title>
    <!-- Tone.js for audio synthesis -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    
    <style>
        body, html {
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    background-color: #FFF; /* Fallback na kulay */
    background-image: url('https://www.transparenttextures.com/patterns/diagmonds.png');
    display: flex;
    justify-content: center;
    align-items: center;
    overflow: hidden;
    font-family: 'Arial', sans-serif;
    -webkit-user-select: none;
    -ms-user-select: none;
    user-select: none;
}

/* I-PASTE MO ITO SA LOOB NG <style> TAG MO */

#shop-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255,255,255,0.3);
}

#player-coin-balance {
    background-color: rgba(0,0,0,0.5);
    padding: 8px 15px;
    border-radius: 20px;
    font-size: 1.2em;
    font-weight: bold;
    color: #FFD700; /* Kulay ginto */
}

#shop-tabs {
    display: flex;
    gap: 10px;
    margin-bottom: 20px;
}

.shop-tab-button {
    flex-grow: 1;
    padding: 10px;
    font-size: 1em;
    background-color: rgba(255,255,255,0.1);
    border: 1px solid rgba(255,255,255,0.3);
    color: white;
    cursor: pointer;
    transition: background-color 0.2s;
}

.shop-tab-button.active {
    background-color: rgba(76, 175, 80, 0.5);
    border-color: rgba(76, 175, 80, 0.8);
}

#shop-items-container {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
    gap: 15px;
    max-height: 50vh;
    overflow-y: auto;
    padding: 10px;
    background: rgba(0,0,0,0.2);
    border-radius: 8px;
}

.shop-item {
    background-color: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 8px;
    padding: 10px;
    text-align: center;
    display: flex;
    flex-direction: column;
    justify-content: space-between;
}

.shop-item-preview {
    width: 100%;
    height: 100px;
    background-size: contain;
    background-repeat: no-repeat;
    background-position: center;
    margin-bottom: 10px;
}

.shop-item-name {
    font-weight: bold;
    font-size: 0.9em;
    min-height: 35px; /* Para pantay-pantay */
}

.shop-item-button {
    padding: 8px;
    margin-top: 10px;
    border: none;
    border-radius: 5px;
    font-weight: bold;
    cursor: pointer;
    width: 100%;
    font-size: 0.8em;
}

.buy-button { background-color: #0d6efd; color: white; }
.equip-button { background-color: #198754; color: white; }
.equipped-button { background-color: #6c757d; color: white; cursor: not-allowed; }



#cue-stick-element {
    display: none;
    position: absolute;
    width: 500px; /* <--- IDAGDAG MO ITONG LINYA PARA HUMABA */
    height: 150px;
    pointer-events: none;
    z-index: 30;
    transform-origin: 100% 50%;
}

        #game-wrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        /* ITO ANG IPAPALIT MO SA LUMANG #game-canvas CSS */

/* ITO ANG IPAPALIT MO SA LUMANG #game-canvas CSS */

#table-frame {
    /* Ang JavaScript na ang bahala sa pag-sukat para maging fullscreen. */

    /* Ito ang itsura ng frame */
    padding: 25px; /* Kapal ng banda galing sa code mo */
    background-image: url('https://www.transparenttextures.com/patterns/shley-tree-1.png');
    background-color: #e09412;
    border-radius: 10px;
    box-shadow: 
        0 10px 25px rgba(0,0,0,0.6), 
        inset 0 0 10px rgba(0,0,0,0.7),
        inset 2px 2px 5px rgba(255, 255, 255, 0.2),
        inset -2px -2px 5px rgba(0, 0, 0, 0.4);

    /* Mahalaga ito para ang canvas ay magkasya sa loob ng padding */
    box-sizing: border-box;
    display: flex;
}

#game-canvas {
    background-color: #f0a93e; /* Kulay ng felt galing sa code mo */
    background-image: url('https://www.transparenttextures.com/patterns/wood.png');
    cursor: crosshair;

    /* Ito ang nagpapalaki sa canvas para sakupin ang buong space sa loob ng frame */
    width: 100%;
    height: 100%;
}

#ghost-hand {
    display: none; /* Nakatago by default */
    position: absolute; /* Para lumutang at masunod ang cursor */
    width: 80px; /* Sukat ng kamay, pwede mong baguhin */
    height: auto;
    opacity: 0.7; /* Para magmukha siyang "ghost" (70% solid) */
    z-index: 50; /* Para siguradong nasa ibabaw siya ng canvas */
    pointer-events: none; /* SUPER IMPORTANTE: Para hindi niya harangan ang pag-click */
    transform: translate(-25px, -15px); /* Ina-adjust ang pwesto para ang daliri ang nasa cursor */
}

        
        /* UI Containers */
        #non-interactive-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 5;
        }
        #message-box {
    position: absolute;
    top: 20px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0,0,0,0.7);
    color: #FFD700; /* <-- Pinalitan ng kulay ginto/dilaw */
    padding: 10px 20px;
    border-radius: 10px;
    font-size: 1.2em;
    display: none;
    text-align: center;
    font-weight: bold; /* <-- Dinagdag para mas makapal */
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); /* <-- Dinagdag para mas lalong kitang-kita */
}

        .info-box {
    position: absolute;
    color: #FFD700; /* Pinalitan ng kulay ginto/dilaw */
    background-color: rgba(0, 0, 0, 0.7); /* Pinalitan ng madilim na background */
    border: 1px solid rgba(255, 255, 255, 0.2); /* Pinaliwanag nang bahagya ang border para bumagay */
    padding: 4px 7px;
    border-radius: 10px;
    font-size: 0.8em;
    font-weight: bold;
    text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.6); /* Inayos para bumagay sa bagong kulay */
}

        #player-info { top: 0px; left: 120px; }
        #opponent-info { top: 0px; right: 120px; }
        
        .ui-button {
            position: absolute;
            padding: 10px 15px;
            font-size: 1em;
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 5px;
            cursor: pointer;
            pointer-events: all;
            z-index: 10;
        }

        #exit-button {
            bottom: 0px; 
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(220, 53, 69, 0.5);
            padding: 4px 16px;
            font-size: 0.8em;
            z-index: 100;
            transition: background-color 0.2s;
        }
        #exit-button:hover {
            background-color: rgba(220, 53, 69, 0.8);
        }

        .icon-button {
            background-color: rgba(0, 0, 0, 0.6);
            width: 40px;
            height: 40px;
            display: flex;
            justify-content: center;
            align-items: center;
            border-radius: 50%;
            border: 2px solid rgba(255, 255, 255, 0.5);
            box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        
        #fullscreen-button {
            top: 50%;
            right: 5px;
            transform: translateY(-50%);
        }
        
        #card-hand-container, #poker-foul-cards {
            position: absolute;
            top: 0px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: row; 
            gap: 8px; 
            pointer-events: all;
            z-index: 10;
        }

        #poker-foul-cards {
            top: auto; 
            position: relative;
            transform: none;
            left: auto;
            margin-top: 20px;
        }


        .card {
            width: 40px;
            height: 60px;
            background-color: rgba(255, 255, 255, 0.1); 
            border: 1px solid rgba(255, 255, 255, 0.2); 
            border-radius: 4px; 
            display: flex;
            flex-direction: column; 
            justify-content: space-around; 
            align-items: center;
            font-weight: bold;
            color: white; 
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5); 
            transition: transform 0.2s ease-in-out;
        }
         #card-hand-container .card {
            width: 20px;
            height: 35px;
        }
        .card-rank { font-size: 1.5em; }
        .card-suit { font-size: 1.2em; }
        #card-hand-container .card-rank { font-size: 1em; }
        #card-hand-container .card-suit { font-size: 0.9em; }

        .card.face-down {
            background-image: linear-gradient(135deg, #4a90e2 25%, #50e3c2 100%);
            cursor: pointer;
        }
        .card.face-down:hover {
            transform: translateY(-10px) scale(1.05);
        }

        /* Controls */
        .control-area {
            position: absolute;
            display: flex;
            align-items: center;
            justify-content: center;
            pointer-events: all;
            z-index: 20;
        }

        #power-control {
            right: 50px;
            top: 50%;
            transform: translateY(-50%);
            width: 50px;
            height: 200px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            flex-direction: column;
            justify-content: flex-end;
        }
        #power-bar {
            width: 100%;
            background: linear-gradient(to top, #00ff00, #ffff00, #ff0000);
            border-radius: 8px;
            height: 0%;
        }

        #pektus-control {
            top: 50%;
            left: 5px;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
            background-color: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            cursor: pointer;
            box-shadow: none;
        }
        #pektus-dot {
            position: absolute;
            width: 8px;
            height: 8px;
            background-color: rgba(255, 0, 0, 0.8);
            border: 1px solid white;
            border-radius: 50%;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
        }

        .arrow-button {
            position: absolute;
            bottom: 0px;
            width: 70px;
            height: 33px;
            background-color: rgba(0, 0, 0, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
            user-select: none;
        }
        #left-arrow {
            right: 50%;
            transform: translateX(-120px);
        }
        #right-arrow {
            left: 50%;
            transform: translateX(120px);
        }


        /* Modals and Overlays */
        .modal-overlay {
            display: none; 
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            justify-content: center;
            align-items: center;
            text-align: center;
            color: white;
            flex-direction: column;
            z-index: 200;
        }
        #confirm-exit-modal {
            z-index: 300; /* Ensure this is on top of all other modals */
        }
        #game-mode-select {
            display: flex; 
        }
        .modal-overlay h2 {
            font-size: 2.5em;
            margin-bottom: 30px;
        }
        .menu-button {
            font-size: 1.2em;
            padding: 15px 20px;
            margin: 8px;
            border-radius: 10px;
            border: 2px solid rgba(255, 255, 255, 0.7);
            background-color: rgba(76, 175, 80, 0.5);
            color: white;
            cursor: pointer;
            width: 300px;
            pointer-events: all;
            transition: background-color 0.3s, opacity 0.3s;
        }
        .menu-button:disabled {
            background-color: rgba(108, 117, 125, 0.3);
            border-color: rgba(255, 255, 255, 0.3);
            opacity: 0.6;
            cursor: not-allowed;
        }
        .back-button {
            background-color: rgba(108, 117, 125, 0.5);
            margin-top: 20px;
        }
        
        #winner-modal h2 {
            margin-bottom: 0;
        }
        #winner-modal #play-again-button {
            font-size: 1.2em;
            padding: 10px 20px;
            margin-top: 30px;
            border-radius: 10px;
            border: none;
            cursor: pointer;
            background-color: #4CAF50;
            color: white;
        }

        #online-menu input {
            font-size: 1em;
            padding: 10px;
            margin: 10px;
            width: 250px;
            border-radius: 5px;
            border: 1px solid #ccc;
        }
        #opponent-hand-reveal {
            margin-top: 20px;
        }
        #opponent-hand-reveal .card {
            transform: scale(0.8);
        }

        /* Instruction Modal Styles */
        .instruction-modal .content, #leaderboard-modal .content {
            background-color: rgba(40, 40, 90, 0.85);
            padding: 20px 30px;
            border-radius: 15px;
            max-width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            border: 1px solid rgba(255,255,255,0.2);
        }
        .instruction-modal .play-button-container {
            margin-bottom: 20px;
        }
        .instruction-modal p {
            font-style: italic;
            line-height: 1.6;
            font-size: 1.1em;
            text-align: left;
            transform: skewX(-8deg);
        }
        .instruction-modal h2 {
            transform: skewX(-8deg);
        }

        /* Guide Text Style */
        .guide-text {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 0, 0.8);
            color: black;
            padding: 10px 20px;
            border-radius: 10px;
            font-size: 1.1em;
            font-weight: bold;
            display: none; 
            text-align: center;
        }
        
        /* Waiting Room Style */
        #waiting-room p {
            font-size: 1.2em;
            margin-bottom: 15px;
        }
        #waiting-room #game-id-display {
            background-color: rgba(0,0,0,0.4);
            padding: 15px 25px;
            border-radius: 8px;
            font-size: 2.5em;
            font-weight: bold;
            letter-spacing: 5px;
            border: 1px solid rgba(255,255,255,0.3);
            margin-bottom: 20px;
            cursor: pointer;
        }

        /* Confirmation Modal Styles */
        #confirm-exit-modal .button-group {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }
        #confirm-exit-modal .confirm-button {
            width: 120px;
            pointer-events: all;
        }
        #confirm-exit-yes {
            background-color: rgba(220, 53, 69, 0.7);
        }
        #confirm-exit-cancel {
            background-color: rgba(108, 117, 125, 0.7);
        }

        /* Leaderboard Style */
        #leaderboard-modal .content {
              width: 80%; 
              max-width: 500px;
        }
        #leaderboard-modal table {
            width: 100%; 
            text-align: left; 
            border-collapse: collapse;
        }
        #leaderboard-modal th, #leaderboard-modal td {
            padding: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.3);
        }
#chat-container {
    position: absolute; /* ITO ANG PINAKA-IMPORTANTE */
    bottom: 10px;
    left: 10px;
    width: 300px;
    height: 200px;
    background-color: rgba(0, 0, 0, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.2);
    border-radius: 8px;
    display: none; 
    flex-direction: column;
    z-index: 150;
    pointer-events: all;
    font-size: 0.9em;
}

#chat-messages {
    flex-grow: 1;
    overflow-y: auto;
    padding: 8px;
    display: flex;
    flex-direction: column-reverse; /* Para laging nasa baba ang bagong message */
}

#chat-messages p {
    margin: 2px 0;
    padding: 4px 8px;
    border-radius: 5px;
    color: white;
    word-wrap: break-word;
}

#chat-messages .my-message {
    background-color: #007bff;
    align-self: flex-end; /* Sa kanan ang sarili mong message */
    text-align: right;
}

#chat-messages .opponent-message {
    background-color: #454d55;
    align-self: flex-start; /* Sa kaliwa ang message ng kalaban */
    text-align: left;
}


#chat-input-area {
    display: flex;
    padding: 5px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
}

#chat-input {
    flex-grow: 1;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.2);
    color: white;
    padding: 5px;
    border-radius: 4px;
}

#chat-send-btn {
    margin-left: 5px;
    background-color: #28a745;
    border: none;
    color: white;
    padding: 5px 10px;
    border-radius: 4px;
    cursor: pointer;
}

#voice-toggle-button {
    position: absolute;
    top: 5px;
    left: 5px;
    z-index: 150;
}



    </style>
</head>
    <body>
        <div id="game-wrapper">

    <button id="voice-toggle-button" class="ui-button icon-button" title="Toggle AI Voice">
        <svg id="voice-on-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;">
            <path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-1.414 1.414A6.472 6.472 0 0 1 12.026 8a6.472 6.472 0 0 1-1.904 4.596l1.414 1.414zM10.121 12.596A6.48 6.48 0 0 0 12.026 8a6.48 6.48 0 0 0-1.905-4.596l-1.414 1.414A4.486 4.486 0 0 1 10.026 8a4.486 4.486 0 0 1-1.319 3.182l1.414 1.414zM8.707 11.182A2.482 2.482 0 0 0 9.026 8a2.482 2.482 0 0 0-.32-1.182L8 7.525v1.95l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10H1.5A.5.5 0 0 1 1 9.5v-3A.5.5 0 0 1 1.5 6h2.325l2.363-2.39a.5.5 0 0 1 .529-.06z"/>
        </svg>
        <svg id="voice-off-icon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white; display: none;">
            <path d="M11.536 14.01A8.473 8.473 0 0 0 14.026 8a8.473 8.473 0 0 0-2.49-6.01l-1.414 1.414A6.472 6.472 0 0 1 12.026 8c0 1.554-.54 2.97-.904 4.596l1.414 1.414zM10.121 12.596A6.48 6.48 0 0 0 12.026 8a6.48 6.48 0 0 0-1.905-4.596l-1.414 1.414A4.486 4.486 0 0 1 10.026 8c0 .93-.28 1.78-.752 2.582l1.414 1.414zM8.707 11.182A2.482 2.482 0 0 0 9.026 8a2.482 2.482 0 0 0-.32-1.182L8 7.525v1.95l.707.707zM6.717 3.55A.5.5 0 0 1 7 4v8a.5.5 0 0 1-.812.39L3.825 10H1.5A.5.5 0 0 1 1 9.5v-3A.5.5 0 0 1 1.5 6h2.325l2.363-2.39a.5.5 0 0 1 .529-.06zm-6.288-.31L1.5 2.5v11l-.288-.288a.5.5 0 0 1 0-.707l12-12a.5.5 0 0 1 .707.707L1.135 14.135a.5.5 0 0 1-.707 0L.139 13.849a.5.5 0 0 1 0-.707l12-12a.5.5 0 0 1 .707.707L.429 3.24z"/>
        </svg>
    </button>


        

            <img id="cue-stick-element" src="https://i.imgur.com/FYXWKhr.png">


            <div id="table-frame">
    <canvas id="game-canvas"></canvas>
</div>


<button id="chat-toggle-button" class="icon-button" style="display: none; position: absolute; top: 75%; left: 5px; transform: translateY(-50%); z-index: 151; background: none; border: none; box-shadow: none; width: 30px; height: 30px;">
    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;">
        <path d="M0 2a2 2 0 0 1 2-2h12a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-2.5a1 1 0 0 0-.8.4l-1.9 2.533a1 1 0 0 1-1.6 0L5.3 12.4a1 1 0 0 0-.8-.4H2a2 2 0 0 1-2-2V2zm2-1a1 1 0 0 0-1 1v8a1 1 0 0 0 1 1h2.5a2 2 0 0 1 1.6.8L8 14.333 9.9 11.8a2 2 0 0 1 1.6-.8H14a1 1 0 0 0 1-1V2a1 1 0 0 0-1-1H2z"/>
    </svg>
</button>



            
          <img id="ghost-hand" src="https://i.imgur.com/ZPG3GhI.png">

            
                    <div id="non-interactive-overlay">
            <div id="player-info" class="info-box">You: ?</div>
            <div id="opponent-info" class="info-box">Opponent: ?</div>
            <div id="message-box"></div>
            <div id="cue-ball-guide" class="guide-text"></div>
<img id="ghost-hand" src="https://i.imgur.com/ZPG3GhI.png">

<div id="chat-container">
    <div id="chat-messages">
        </div>
    <div id="chat-input-area">
        <input type="text" id="chat-input" placeholder="Type a message...">
        <button id="chat-send-btn">Send</button>
    </div>
</div>

            <div id="drag-guide-text" class="guide-text">Place the cue ball</div>
        </div>

        
        <!-- Interactive UI elements -->
        <button id="exit-button" class="ui-button">Exit</button>
        <div id="card-hand-container"></div>
        <button id="fullscreen-button" class="ui-button icon-button" title="Toggle Fullscreen">
            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="currentColor" viewBox="0 0 16 16" style="color: white;">
                <path d="M1.5 1a.5.5 0 0 0-.5.5v4a.5.5 0 0 1-1 0v-4A1.5 1.5 0 0 1 1.5 0h4a.5.5 0 0 1 0 1h-4zM10 .5a.5.5 0 0 1 .5-.5h4A1.5 1.5 0 0 1 16 1.5v4a.5.5 0 0 1-1 0v-4a.5.5 0 0 0-.5-.5h-4a.5.5 0 0 1-.5-.5zM.5 10a.5.5 0 0 1 .5.5v4a.5.5 0 0 0 .5.5h4a.5.5 0 0 1 0 1h-4A1.5 1.5 0 0 1 0 14.5v-4a.5.5 0 0 1 .5-.5zm15 0a.5.5 0 0 1 .5.5v4a1.5 1.5 0 0 1-1.5 1.5h-4a.5.5 0 0 1 0-1h4a.5.5 0 0 0 .5-.5v-4a.5.5 0 0 1 .5-.5z"/>
            </svg>
        </button>
        
        <!-- Controls -->
        <div id="power-control" class="control-area">
            <div id="power-bar"></div>
        </div>
        <div id="pektus-control" class="control-area">
            <div id="pektus-dot"></div>
        </div>
        <div id="left-arrow" class="arrow-button control-area">&lt;</div>
        <div id="right-arrow" class="arrow-button control-area">&gt;</div>
    </div>

    <!-- Game Mode Selection -->
    <div id="game-mode-select" class="modal-overlay">
    <h2>Select Game Mode</h2>
    <button class="menu-button" id="vs-ai-button">Player vs AI</button>
    <button class="menu-button" id="online-button">Online Multiplayer</button>
    
    <button class="menu-button" id="shop-button" style="background-color: rgba(13, 110, 253, 0.5);">Shop</button>
    
    <button class="menu-button" id="leaderboard-button" style="background-color: rgba(255, 193, 7, 0.5);">Leaderboard</button>
</div>


    <!-- AI Sub-Menu -->
    <div id="ai-menu" class="modal-overlay">
        <h2>Player vs AI</h2>
        <button class="menu-button" id="ai-straight-ball-button">STRAIGHT BALL</button>
        <button class="menu-button" id="ai-poker-button">POKER</button>
        <button class="menu-button" id="ai-61-button">61 BALL</button>
        <button class="menu-button back-button" id="ai-back-button">Back</button>
    </div>

    <!-- Difficulty Selection Overlay -->
    <div id="difficulty-select" class="modal-overlay">
        <h2>Select Difficulty</h2>
        <button class="menu-button" data-difficulty="easy">Easy</button>
        <button class="menu-button" data-difficulty="hard">Hard</button>
        <button class="menu-button" data-difficulty="pro">Professional</button>
        <button class="menu-button back-button" id="difficulty-back-button">Back</button>
    </div>
    
    <!-- Instruction Modals -->
    <div id="straight-ball-instructions" class="modal-overlay instruction-modal">
        <div class="content">
            <div class="play-button-container">
                 <button class="menu-button" id="play-straight-ball-button">Play</button>
            </div>
            <h2>Straight Ball Rules</h2>
            <p>
                - Continue your turn by legally pocketing your balls.<br>
                - The first color legally pocketed on an 'open table' becomes yours.<br>
                - <strong>Foul:</strong> Pocketing the cue ball returns one of your pocketed balls to the table.<br>
                - <strong>Foul:</strong> Hitting an opponent's ball first returns any of your balls pocketed on that shot.<br>
                - First to pocket all their balls wins!
            </p>
        </div>
    </div>

    <div id="poker-instructions" class="modal-overlay instruction-modal">
        <div class="content">
             <div class="play-button-container">
                <button class="menu-button" id="play-poker-button">Play</button>
            </div>
            <h2>Poker Pool Rules</h2>
            <p>
                - You get 7 cards. Pocket balls matching your cards to win.<br>
                - A hand of all Kings is an automatic win.<br>
                - <strong>Cue Ball Foul:</strong> Pocketing the cue ball forces you to draw a penalty card.<br>
                - <strong>Last Ball Foul:</strong> If you scratch on your last ball, you draw a card. A King wins the game, otherwise, play continues with the new card.<br>
                - A penalty card matching a pocketed ball is discarded.
            </p>
        </div>
    </div>
    
    <div id="61-ball-instructions" class="modal-overlay instruction-modal">
        <div class="content">
             <div class="play-button-container">
                <button class="menu-button" id="play-61-ball-button">Play</button>
            </div>
            <h2>61 Ball Rules</h2>
            <p>
                - The goal is to be the first to score 61 points.<br>
                - You must always hit the lowest numbered chip on the table first.<br>
                - Your score is the sum of the numbers on the chips you legally pocket.<br>
                - <strong>Example:</strong> Hit the 1-chip first, and the 15-chip is pocketed. You get 15 points.<br>
                - Your turn continues as long as you legally pocket a chip.<br>
                - <strong>Foul:</strong> Hitting the wrong chip first, or scratching the cue chip, ends your turn. Your opponent gets ball-in-hand. Any chips pocketed on a foul shot will be returned to the table.
            </p>
        </div>
    </div>

    <!-- Poker Foul Card Pick -->
    <div id="poker-foul-card-pick-modal" class="modal-overlay">
        <h2>Foul! Pick a card.</h2>
        <div id="poker-foul-cards"></div>
    </div>

    <!-- Online Game Type Selection -->
    <div id="online-game-select" class="modal-overlay">
        <h2>Online: Select Game Type</h2>
        <button class="menu-button" id="online-poker-button">POKER POOL</button>
        <button class="menu-button" id="online-straight-ball-button">STRAIGHT BALL</button>
        <button class="menu-button" id="online-61-button">61 BALL</button>
        <button class="menu-button back-button" id="online-select-back-button">Back</button>
    </div>

    <!-- Online Multiplayer Menu -->
        <div id="online-menu" class="modal-overlay">
        <h2>Online Multiplayer</h2>
        
        <button class="menu-button" id="find-match-button" style="background-color: rgba(23, 162, 184, 0.5);">Find Match</button>
        <p style="margin: 15px 0; font-size: 0.9em;">- OR -</p>
        <button class="menu-button" id="create-game-button">Create Game (Private)</button>
        <input type="text" id="game-id-input" placeholder="Enter Game ID">
        <button class="menu-button" id="join-game-button">Join Game</button>
        <button class="menu-button back-button" id="online-back-button">Back</button>
    </div>
    

    <!-- Waiting Room -->
    <div id="waiting-room" class="modal-overlay">
        <h2>Waiting for Opponent...</h2>
        <p>Share this Game ID with your friend:</p>
        <div id="game-id-display" title="Click to copy"></div>
        <button class="menu-button back-button" id="cancel-game-button">Cancel</button>
    </div>

    <div id="matchmaking-wait-modal" class="modal-overlay">
        <h2>Searching for an opponent...</h2>
        <button id="cancel-matchmaking-button" class="menu-button back-button" style="width: 250px;">Cancel</button>
    </div>



    <!-- Winner Modal -->
    <div id="winner-modal" class="modal-overlay">
        <h2 id="winner-text"></h2>
        <button id="play-again-button">Play Again</button>
        <button id="rematch-button" class="menu-button" style="display: none; width: 250px; margin-top: 15px;">Rematch</button>
        <div id="opponent-hand-reveal"></div>
    </div>

    <!-- Exit Confirmation Modal -->
    <div id="confirm-exit-modal" class="modal-overlay">
        <h2>Are you sure you want to exit?</h2>
        <p>This will count as a loss if you are in an online game.</p>
        <div class="button-group">
            <button id="confirm-exit-yes" class="menu-button confirm-button">Yes</button>
            <button id="confirm-exit-cancel" class="menu-button confirm-button">Cancel</button>
        </div>
    </div>

    <!-- Leaderboard Modal -->
    <div id="leaderboard-modal" class="modal-overlay">
        <div class="content">
            <h2>Top Players</h2>
            <table>
                <thead>
                    <tr>
                        <th>Rank</th>
                        <th>Name</th>
                        <th>Wins</th>
                    </tr>
                </thead>
                <tbody id="leaderboard-body">
                    <!-- Data will be loaded here by JavaScript -->
                    <tr><td colspan="3" style="text-align: center; padding: 20px;">Loading...</td></tr>
                </tbody>
            </table>
            <button class="menu-button back-button" id="leaderboard-back-button">Back</button>
        </div>
    </div>

<div id="shop-modal" class="modal-overlay">
    <div class="content" style="width: 90%; max-width: 800px; background-color: rgba(20, 20, 50, 0.9);">
        <div id="shop-header">
            <h2>Shop</h2>
            <div id="player-coin-balance">Loading...</div>
        </div>

        <div id="shop-tabs">
            <button class="shop-tab-button active" data-category="cues">Cues</button>
            <button class="shop-tab-button" data-category="tables">Tables</button>
            <button class="shop-tab-button" data-category="chips">Chips</button>
        </div>

        <div id="shop-items-container">
            </div>

        <button class="menu-button back-button" id="shop-back-button" style="margin-top: 20px;">Back</button>
    </div>
</div>


    <script type="module">
        // =========================================================================
// FIREBASE SETUP
// =========================================================================
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
    getFirestore, doc, setDoc, onSnapshot, updateDoc, getDoc, deleteDoc, writeBatch, 
    serverTimestamp, increment, collection, query, orderBy, limit, getDocs, 
    addDoc, runTransaction, where
} from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";


let db, auth;
let firebaseInitialized = false;
let isAuthReady = false;

// =========================================================================
// DOM ELEMENTS
// =========================================================================
// IDAGDAG MO ANG MGA ITO SA IYONG DOM ELEMENTS LIST
const shopButton = document.getElementById('shop-button');
const shopModal = document.getElementById('shop-modal');
const playerCoinBalance = document.getElementById('player-coin-balance');
const shopItemsContainer = document.getElementById('shop-items-container');
const shopBackButton = document.getElementById('shop-back-button');
const shopTabs = document.getElementById('shop-tabs');

const canvas = document.getElementById('game-canvas');
const ctx = canvas.getContext('2d');
const gameWrapper = document.getElementById('game-wrapper');
const messageBox = document.getElementById('message-box');
const winnerModal = document.getElementById('winner-modal');
const winnerText = document.getElementById('winner-text');
const playerInfo = document.getElementById('player-info');
const opponentInfo = document.getElementById('opponent-info');
const powerControl = document.getElementById('power-control');
const powerBar = document.getElementById('power-bar');
const gameModeSelect = document.getElementById('game-mode-select');
const difficultySelect = document.getElementById('difficulty-select');
const onlineMenu = document.getElementById('online-menu');
const exitButton = document.getElementById('exit-button');
const vsAiButton = document.getElementById('vs-ai-button');
const onlineButton = document.getElementById('online-button');
const createGameButton = document.getElementById('create-game-button');
const joinGameButton = document.getElementById('join-game-button');
const gameIdInput = document.getElementById('game-id-input');
const difficultyBackButton = document.getElementById('difficulty-back-button');
const onlineBackButton = document.getElementById('online-back-button');
const cardHandContainer = document.getElementById('card-hand-container');
const opponentHandReveal = document.getElementById('opponent-hand-reveal');
const playAgainButton = document.getElementById('play-again-button');
const aiMenu = document.getElementById('ai-menu');
const aiStraightBallButton = document.getElementById('ai-straight-ball-button');
const aiPokerButton = document.getElementById('ai-poker-button');
const ai61Button = document.getElementById('ai-61-button');
const aiBackButton = document.getElementById('ai-back-button');
const straightBallInstructions = document.getElementById('straight-ball-instructions');
const pokerInstructions = document.getElementById('poker-instructions');
const sixtyOneInstructions = document.getElementById('61-ball-instructions');
const playStraightBallButton = document.getElementById('play-straight-ball-button');
const playPokerButton = document.getElementById('play-poker-button');
const play61BallButton = document.getElementById('play-61-ball-button');
const cueBallGuide = document.getElementById('cue-ball-guide');
const waitingRoom = document.getElementById('waiting-room');
const gameIdDisplay = document.getElementById('game-id-display');
const cancelGameButton = document.getElementById('cancel-game-button');
const onlineGameSelect = document.getElementById('online-game-select');
const onlinePokerButton = document.getElementById('online-poker-button');
const onlineStraightBallButton = document.getElementById('online-straight-ball-button');
const online61Button = document.getElementById('online-61-button');
const onlineSelectBackButton = document.getElementById('online-select-back-button');
const confirmExitModal = document.getElementById('confirm-exit-modal');
const confirmExitYes = document.getElementById('confirm-exit-yes');
const confirmExitCancel = document.getElementById('confirm-exit-cancel');
const pektusControl = document.getElementById('pektus-control');
const pektusDot = document.getElementById('pektus-dot');
const leftArrow = document.getElementById('left-arrow');
const rightArrow = document.getElementById('right-arrow');
const fullscreenButton = document.getElementById('fullscreen-button');
const pokerFoulCardPickModal = document.getElementById('poker-foul-card-pick-modal');
const pokerFoulCardsContainer = document.getElementById('poker-foul-cards');
const leaderboardModal = document.getElementById('leaderboard-modal');
const leaderboardButton = document.getElementById('leaderboard-button');
const leaderboardBackButton = document.getElementById('leaderboard-back-button');
const leaderboardBody = document.getElementById('leaderboard-body');
const ghostHand = document.getElementById('ghost-hand');
const dragGuideText = document.getElementById('drag-guide-text');
const findMatchButton = document.getElementById('find-match-button');
const matchmakingWaitModal = document.getElementById('matchmaking-wait-modal');
const cancelMatchmakingButton = document.getElementById('cancel-matchmaking-button');
const chatContainer = document.getElementById('chat-container');
const chatMessages = document.getElementById('chat-messages');
const chatInput = document.getElementById('chat-input');
const chatSendBtn = document.getElementById('chat-send-btn');
const cueStickElement = document.getElementById('cue-stick-element'); // <--- IDAGDAG MO ITO


// =========================================================================
// CONSTANTS & GAME STATE
// =========================================================================
// ILAGAY MO ITO KASAMA NG IBANG CONSTANTS SA TAAS
// Idagdag mo ito
const CONSOLATION_REWARD = 550; // 10 PC kahit matalo


// Idagdag mo itong line na ito
const DAILY_REWARD = 50; // 50 PC para sa daily login

const WIN_REWARD = 100; // Coins na mapapanalunan

// FINAL VERSION: PALITAN ANG BUONG const SHOP_ITEMS OBJECT NITO

const SHOP_ITEMS = {
    cues: [
        { id: 'default_cue', name: 'Standard Cue', price: 0, preview: 'https://i.ibb.co/L6V2MhW/FYXWKhr.png' },
        { id: 'carbon_cue', name: 'Carbon Fiber Cue', price: 500, preview: 'https://i.imgur.com/Z79LWaB.png' },
        { id: 'royal_cue', name: 'Royal Wood Cue', price: 1500, preview: 'https://i.ibb.co/yQxK6N7/f-Jv9-J7-T.png' }
    ],
    tables: [
        { id: 'default_table', name: 'Classic Green', price: 0, preview: 'https://i.ibb.co/yS5J9vF/Jj-Y7-W0-E.png' },
        { id: 'blue_felt', name: 'Tournament Blue', price: 800, preview: 'https://i.ibb.co/wYgD1t4/y-A0x-Rk4.png' },
        { id: 'red_felt', name: 'VIP Red', price: 2000, preview: 'https://i.ibb.co/M8VzLh2/p5-A7-Wn1.png' }
    ],
    chips: [
        { id: 'default_chips', name: 'Standard Set', price: 0, preview: 'https://i.ibb.co/nMSMpxj/2s9-V2z-D.png' },
        { id: 'neon_chips', name: 'Neon Set', price: 1200, preview: 'https://i.ibb.co/D8d3wN2/K7n6-E2-C.png' }
    ]
};




// Data para sa itsura ng mga biniling gamit
const ITEM_ASSETS = {
    cues: {
        'default_cue': 'https://i.imgur.com/FYXWKhr.png',
        'carbon_cue': 'https://i.imgur.com/vHq0mmP.png',
        'royal_cue': 'https://i.imgur.com/fJv9J7T.png'
    },
    tables: {
        'default_table': "#f0a93e", // Default color from your CSS
        'blue_felt': "#34568B",
        'red_felt': "#C04000"
    },
    chips: {
        'default_chips': { base: '#FFD700', red: '#C8102E', blue: '#0033A0', cue: '#1a1a1a', cueAccent: '#444444', cueCenter: '#000000' },
        'neon_chips': { base: '#E0E0E0', red: '#FF1493', blue: '#00FFFF', cue: '#333333', cueAccent: '#FFFFFF', cueCenter: '#FF1493' }
    }
};


const TABLE_ASPECT_RATIO = 2;
const BALL_RADIUS = 16;      // Mula sa 18
const CUE_BALL_RADIUS = 18;  // Mula sa 20
const HOLE_RADIUS = 35;      // Mula sa 40
const FRICTION = 0.97; 
const MIN_VELOCITY = 0.05;
const ROTATION_SPEED = 0.001;
const TOUCH_AIM_SENSITIVITY = 0.00001;

// =================== PALITAN MO ANG BUONG aiChatter NITO ===================
const aiChatter = {
    'en': { // English Messages
        start: ["Good luck!", "Have a good game.", "Let's play!"],
        goodShot: ["Nice one!", "Great shot!", "Impressive."],
        foul: ["Oops, my bad.", "My mistake.", "Darn."],
        playerGoodShot: ["Wow, nice shot!", "Great play!", "Clean shot."],
        // --- BAGONG DAGDAG ---
        playerFoul: ["Tough break.", "That happens.", "Shake it off.", "Unlucky."],
        winning: ["Almost there...", "One more to go."],
        lose: ["Good game! You played well.", "GG. Rematch?"],
        win: ["Good game! Well played.", "That was a close one!"]
    },
    'tl': { // Tagalog Messages
        start: ["Good luck!", "Game na!", "Simulan na natin!"],
        goodShot: ["Ayos!", "chamba lang!", "Swabe!", "Pasok! ðŸ˜Ž"],
        foul: ["Ay, sablay.ðŸ˜‚", "Sayang.ðŸ¥º", "Oops, mali.ðŸ¤­"],
        playerGoodShot: ["Wow, nice shot!ðŸ˜²", "Ang galing naman!", "Ganda ng tira mo!", "Hanep, smooth! ðŸ‘"],
        // --- BAGONG DAGDAG ---
        playerFoul: ["Sayang 'yon.", "Nangyayari talaga 'yan.", "Bawi na lang.", "Ayy, malas."],
        winning: ["Isa na lang!", "Malapit na...", "Mukhang akin na 'to."],
        lose: ["Good game! Ang galing mo!", "GG! Rematch?"],
        win: ["Good game! Salamat sa laro.", "Panalo!"]
    }
};
// =================== HANGGANG DITO ===================


// --- Game State Variables ---
let isAiVoiceEnabled = true; // By default, naka-ON ang voice
let scale = 1;
let table = { width: 0, height: 0 };
let chips = [];
let holes = [];
let cueStick = { angle: 0, length: 10000, visible: true, power: 0, pullback: 0 };
let gameState = 'menu';
let gameMode = 'ai-classic';
let playerTurn = true;
let colorsAssigned = false;
let playerChipsType = null;
let opponentChipsType = null;
let canMoveCueBall = false;
let chipsMoving = false;
let chipsPocketedInTurn = [];
let firstChipHitInTurn = null;
let isPoweringUp = false;
let isAimingOnCanvas = false;
let isDraggingCueBall = false;
let difficulty = 'easy';
let deck = [];
let playerHand = [];
let opponentHand = [];
let originalPlayerHand = [];
let originalOpponentHand = [];
let selectedGameConfig = {}; 
let isBreakShot = false;
let pektusOffset = { x: 0, y: 0 };
let shotPektusOffset = { x: 0, y: 0 };
let isDraggingPektusDot = false;
let isRotatingLeft = false;
let isRotatingRight = false;
let isInvalidPlacement = false;
let player61Score = 0;
let opponent61Score = 0;
let lowestChipNumber = 1;
let aiConsecutivePots = 0;

// PALITAN MO ANG BUONG SECTION NA ITO NG NASA BABA

// --- Online Multiplayer Variables ---
let gameId = null;
let localPlayerId = null;
let localPlayerUid = null;
let currentTurnUid = null;
let unsubscribeGameListener;
let isOnlineGame = false;
let isMyTurnOnline = false;
let isProcessingTurnEnd = false;
let lastProcessedTurnId = -1; 
let isSyncing = false;
let selectedOnlineGameType = 'poker';
let lastAimUpdateTime = 0;
const AIM_UPDATE_INTERVAL = 50;
let lastTurnControllerUid = null;
let unsubscribeFromQueue;
let matchmakingTimeoutId = null;
let isAiTakeoverActive = false;

// ITO ANG IDINAGDAG AT INAYOS NA PLAYER PROFILE VARIABLE
let playerProfile = { 
    poolCoins: 0, 
    ownedItems: [], 
    equippedItems: { cue: 'default_cue', table: 'default_table', chips: 'default_chips' } 
};



// --- Audio State ---
let audioInitialized = false;
let chipCollisionSynth, pocketSynth, uiSynth, cueHitSynth, cushionSynth;
let lastCollisionSoundTime = -1;
let lastCushionSoundTime = -1;
let buttonSoundPlaying = false;

const cueStickImage = new Image();
cueStickImage.src = 'https://i.imgur.com/FYXWKhr.png';

// =========================================================================
// CHAT FUNCTIONALITY
// =========================================================================
let unsubscribeFromChat;
let isInitialChatLoad = true;

function setupChatListener(gameIdForChat) {
    if (unsubscribeFromChat) {
        unsubscribeFromChat();
    }
    
    chatMessages.innerHTML = '';
    isInitialChatLoad = true;
    
    const chatToggleButton = document.getElementById('chat-toggle-button');
    if(chatToggleButton) chatToggleButton.style.display = 'flex';

    const messagesRef = collection(db, "games", gameIdForChat, "messages");
    const q = query(messagesRef, orderBy("timestamp"), limit(200)); 

    unsubscribeFromChat = onSnapshot(q, (snapshot) => {
        
        snapshot.docChanges().forEach(change => {
            if (change.type === 'added' && !isInitialChatLoad) {
                const messageData = change.doc.data();
                if (messageData.senderId !== localPlayerUid && messageData.text) {
                    showMessage(`Opponent: ${messageData.text}`, 5000);
                }
            }
        });

        const allMessages = [];
        snapshot.docs.forEach(doc => allMessages.push(doc.data()));
        
        chatMessages.innerHTML = '';
        allMessages.reverse().forEach(messageData => { 
            const messageP = document.createElement('p');
            messageP.textContent = messageData.text;

            if (messageData.senderId === localPlayerUid) {
                messageP.className = 'my-message';
            } else {
                messageP.className = 'opponent-message';
            }
            chatMessages.appendChild(messageP);
        });

        isInitialChatLoad = false; 
    });
}

// I-paste itong buong function sa iyong script
async function handleDailyLoginBonus(uid) {
    const today = new Date().toISOString().slice(0, 10); // Kinukuha ang date ngayon (e.g., "2025-10-08")
    const lastLogin = localStorage.getItem('pinoyPoolLastLogin');

    if (lastLogin !== today) {
        // Kung ang huling login ay hindi ngayong araw, bigyan ng bonus!
        localStorage.setItem('pinoyPoolLastLogin', today); // I-save ang petsa ngayon
        
        const playerDocRef = doc(db, "players", uid);
        try {
            await updateDoc(playerDocRef, {
                poolCoins: increment(DAILY_REWARD)
            });
            // I-update din ang local profile para real-time
            playerProfile.poolCoins += DAILY_REWARD;
            playerCoinBalance.textContent = `${playerProfile.poolCoins.toLocaleString()} PC`;
            
            // Magpakita ng message
            showMessage(`Daily Bonus! You received ${DAILY_REWARD} PC!`, 3000);

        } catch (error) {
            console.error("Failed to give daily bonus:", error);
        }
    }
}


// vvvv ITO LANG DAPAT ANG LAMAN NG sendMessage FUNCTION MO vvvv

async function sendMessage() {
    const messageText = chatInput.value.trim();

    if (messageText === '') {
        showMessage("ERROR: Hindi pwedeng walang laman ang message!", 3000);
        return;
    }

    // Tinitingnan kung online o vs AI ang laro
    if (isOnlineGame) {
        // Ito ang logic para sa ONLINE games
        if (!gameId) {
            console.error("Cannot send message, no game ID.");
            return;
        }
        const messagesRef = collection(db, "games", gameId, "messages");
        try {
            await addDoc(messagesRef, {
                text: messageText,
                senderId: localPlayerUid,
                timestamp: serverTimestamp()
            });
        } catch (error) {
            showMessage("FIREBASE ERROR: Tingnan ang console.", 4000);
            console.error("Ang Firebase error ay:", error);
        }

    } else {
        // Ito ang logic para sa OFFLINE (vs AI) games
        const messageP = document.createElement('p');
        messageP.textContent = messageText;
        messageP.className = 'my-message'; // Gagamitin ang style para sa sarili mong message
        chatMessages.insertBefore(messageP, chatMessages.firstChild);
    }

    // Gagawin ito sa parehong online at offline mode
    chatInput.value = '';
    chatContainer.style.display = 'none'; 
}

// ^^^^ HANGGANG DITO ^^^^



// =========================================================================
// AUDIO HANDLING
// =========================================================================
function initAudio() {
    if (audioInitialized || typeof Tone === 'undefined') {
        return Promise.resolve();
    }
    
    return Tone.start().then(() => {
        chipCollisionSynth = new Tone.MembraneSynth({ pitchDecay: 0.008, octaves: 5, oscillator: { type: "triangle" }, envelope: { attack: 0.001, decay: 0.15, sustain: 0, release: 0.1, attackCurve: "exponential", }, }).toDestination();
        chipCollisionSynth.volume.value = -4;
        cueHitSynth = new Tone.PluckSynth({ attackNoise: 1, dampening: 2000, resonance: 0.5, }).toDestination();
        cueHitSynth.volume.value = -1;
        cushionSynth = new Tone.MembraneSynth({ pitchDecay: 0.08, octaves: 2, envelope: { attack: 0.001, decay: 0.1, sustain: 0 } }).toDestination();
        cushionSynth.volume.value = -8;
        pocketSynth = new Tone.NoiseSynth({ noise: { type: 'brown' }, envelope: { attack: 0.005, decay: 0.15, sustain: 0.1 } }).toDestination();
        pocketSynth.volume.value = -5;
        uiSynth = new Tone.PluckSynth({ attackNoise: 0.5, dampening: 4000, resonance: 0.8 }).toDestination();
        uiSynth.volume.value = -4;
        audioInitialized = true;
    }).catch(e => {
        console.error("Could not start Tone.js audio context:", e);
        audioInitialized = false; 
    });
}

async function playButtonSound() {
    if (buttonSoundPlaying) return;
    if (!audioInitialized) await initAudio();
    if (!audioInitialized) return; 
    buttonSoundPlaying = true;
    uiSynth.triggerAttackRelease("C5", "8n");
    setTimeout(() => { buttonSoundPlaying = false; }, 50);
}

async function playCollisionSound(speed) {
    if (!audioInitialized) await initAudio();
    if (!audioInitialized) return;
    const now = Tone.now();
    if (now <= lastCollisionSoundTime) return;
    lastCollisionSoundTime = now + 0.04;
    const volume = -12 + Math.min(1, speed / 25) * 14;
    const note = speed > 15 ? 'C3' : (speed > 5 ? 'A2' : 'G2');
    chipCollisionSynth.volume.value = volume;
    chipCollisionSynth.triggerAttackRelease(note, "32n", now);
}

async function playCushionSound(speed) {
     if (!audioInitialized) await initAudio();
    if (!audioInitialized) return;
    const now = Tone.now();
    if (now <= lastCushionSoundTime) return;
    lastCushionSoundTime = now + 0.03;
    const volume = -12 + Math.min(1, speed / 15) * 8;
    const note = speed > 10 ? 'C2' : 'D1';
    cushionSynth.volume.value = volume;
    cushionSynth.triggerAttackRelease(note, '16n', now);
}

async function playCueHitSound(power) { 
    if (!audioInitialized) await initAudio();
    if (!audioInitialized) return;
    const now = Tone.now();
    const volume = -6 + (power * 6);
    const note = 'C4'; 
    cueHitSynth.volume.value = volume;
    cueHitSynth.triggerAttack(note, now);
}

async function playPocketSound() {
    if (!audioInitialized) await initAudio();
    if (!audioInitialized) return;
    pocketSynth.triggerAttackRelease("0.2");
}

// IDAGDAG MO ANG MGA BAGONG FUNCTIONS NA ITO

async function getPlayerProfile(uid) {
    if (!uid) return;
    const playerDocRef = doc(db, "players", uid);
    try {
        const docSnap = await getDoc(playerDocRef);
        if (docSnap.exists()) {
            const data = docSnap.data();
            // Tinitiyak na may laman ang lahat ng kailangan
            playerProfile = {
                poolCoins: data.poolCoins || 0,
                ownedItems: data.ownedItems || ['default_cue', 'default_table', 'default_chips'],
                equippedItems: data.equippedItems || { cue: 'default_cue', table: 'default_table', chips: 'default_chips' }
            };
        } else {
            // Kung walang data, gawa ng bago (first time player)
            await updatePlayerData(uid, false); // false = hindi nanalo, para ma-setup lang
            await getPlayerProfile(uid); // Tawagin ulit para makuha na yung bagong data
        }
        applyEquippedItems();
    } catch (error) {
        console.error("Error getting player profile:", error);
    }
}

function applyEquippedItems() {
    if (!playerProfile.equippedItems) return;

    // 1. I-apply ang Tako (Cue)
    const equippedCueId = playerProfile.equippedItems.cue || 'default_cue';
    const cueSrc = ITEM_ASSETS.cues[equippedCueId];
    if (cueSrc) {
        cueStickImage.src = cueSrc;
        cueStickElement.src = cueSrc;
    }

    // 2. I-apply ang Mesa (Table)
    const equippedTableId = playerProfile.equippedItems.table || 'default_table';
    const tableColor = ITEM_ASSETS.tables[equippedTableId];
    if (tableColor) {
        document.getElementById('game-canvas').style.backgroundColor = tableColor;
    }

    // 3. I-apply ang Panotsa (Chips) - Ang drawChips() na ang bahala rito.
    // Kailangan lang nating i-redraw para mag-update.
    if (gameState === 'menu') {
        draw();
    }
}


// =========================================================================
// GAME INITIALIZATION & MAIN LOOP
// =========================================================================
function init() {
    resizeCanvas();
    setupEventListeners();
    initializeFirebase(); 
    history.replaceState({ modal: 'gameModeSelect' }, 'Main Menu', '#main');
    update();
}

function update() {
    if (isRotatingLeft || isRotatingRight) {
        if (isRotatingLeft) cueStick.angle -= ROTATION_SPEED;
        if (isRotatingRight) cueStick.angle += ROTATION_SPEED;
        sendLiveAimData();
    }

    if (chipsMoving) {
        updateChipPositions();
    }
    draw();
    requestAnimationFrame(update);
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    drawTable();
    drawChips();

    const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
    if (isMyTurn && gameState === 'aiming') {
        drawGuidelines();
    }

    if ((gameState === 'aiming' || gameState === 'shooting_animation' || (isOnlineGame && !isMyTurnOnline)) && cueStick.visible) {
        drawCueStick();
    }
}

// =========================================================================
// CANVAS & TABLE SETUP
// =========================================================================
// >>>>> ITO ANG FINAL VERSION NG resizeCanvas FUNCTION <<<<<

function resizeCanvas() {
    // Kinukuha ang lumang sukat ng CANVAS para sa ratio calculation
    const oldCanvasWidth = canvas.width;
    const oldCanvasHeight = canvas.height;

    let chipRatios;
    // Tinitiyak na may sukat ang canvas bago kumuha ng ratio para iwas-bug
    if (!isBreakShot && chips.length > 0 && oldCanvasWidth > 0 && oldCanvasHeight > 0) {
        chipRatios = chips.map(c => ({
            x: c.x / oldCanvasWidth,
            y: c.y / oldCanvasHeight
        }));
    }

    // === ITO ANG LOGIC PARA MAGING FULLSCREEN ===
    const containerWidth = window.innerWidth;
    const containerHeight = window.innerHeight;
    const screenAspectRatio = containerWidth / containerHeight;
    const tableFrame = document.getElementById('table-frame');
    let frameWidth, frameHeight;

    if (screenAspectRatio > TABLE_ASPECT_RATIO) {
        // Kung mas malapad (widescreen) ang screen kaysa sa table
        frameHeight = containerHeight; // Punuin ang taas
        frameWidth = frameHeight * TABLE_ASPECT_RATIO; // Kalkulahin ang lapad
    } else {
        // Kung mas matangkad (portrait) o sakto ang screen sa table
        frameWidth = containerWidth; // Punuin ang lapad
        frameHeight = frameWidth / TABLE_ASPECT_RATIO; // Kalkulahin ang taas
    }

    // Itatakda ang sukat ng frame gamit ang JavaScript
    tableFrame.style.width = `${frameWidth}px`;
    tableFrame.style.height = `${frameHeight}px`;
    
    // Ang lahat ng kasunod na code ay tinitiyak na tama pa rin ang physics
    const framePadding = 25 * 2; // 25px sa bawat side, galing sa CSS mo
    
    canvas.width = frameWidth - framePadding;
    canvas.height = frameHeight - framePadding;
    
    table.width = canvas.width;
    table.height = canvas.height;

    scale = frameWidth / 1000; // Ibabase ang scale sa kabuuang lapad ng frame

    setupHoles();
    
    if (isBreakShot || !chipRatios) {
        setupChips();
    } else if (chipRatios) { 
        chips.forEach((chip, i) => {
            const radiusConstant = chip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS;
            if (chipRatios[i]) {
                chip.x = chipRatios[i].x * canvas.width;
                chip.y = chipRatios[i].y * canvas.height;
            }
            chip.radius = radiusConstant * scale;
        });
    }
    // Kung hindi break shot at HINDI tayo nakakuha ng valid ratios (dahil galing sa zero size),
    // hahayaan lang natin ang mga bola sa kanilang pwesto para hindi mag-crash.
}

function setupHoles() {
    const hr = HOLE_RADIUS * scale;
    holes = [
        { x: 0, y: 0, radius: hr }, 
        { x: canvas.width, y: 0, radius: hr }, 
        { x: 0, y: canvas.height, radius: hr }, 
        { x: canvas.width, y: canvas.height, radius: hr }
    ];
}

function setupChips() {
    chips = [];
    const newCueChip = { 
        id: 0, value: 0, x: canvas.width * 0.25, y: canvas.height / 2, 
        vx: 0, vy: 0, radius: CUE_BALL_RADIUS * scale, inPlay: true, color: '#1a1a1a', type: 'cue',
        isPocketing: false, pocketingProgress: 0, pocketingHole: null,
        rotation: 0, rotationSpeed: 0 
    };
    chips.push(newCueChip);

    const objectChipRadius = BALL_RADIUS * scale;

    if (gameMode.includes('straight-ball') || gameMode.includes('poker')) {
        const redChipsSource = [];
        const blueChipsSource = [];
        for (let i = 1; i <= 12; i++) {
            if (i <= 6) { 
                redChipsSource.push({ id: i, color: '#C8102E', type: 'red', value: i }); 
            } else { 
                blueChipsSource.push({ id: i, color: '#0033A0', type: 'blue', value: i });
            }
        }
        
        const startX = canvas.width * 0.7;
        const startY = canvas.height / 2;
        const colSpacing = objectChipRadius * 2.1;
        const rowSpacing = objectChipRadius * 1.8;
        
        const positions = [];
        const rows = 4;
        const cols = 3;
        
        const totalHeight = (rows - 1) * rowSpacing;
        const initialY = startY - totalHeight / 2;

        for (let row = 0; row < rows; row++) {
            for (let col = 0; col < cols; col++) {
                positions.push({
                    x: startX + col * colSpacing,
                    y: initialY + row * rowSpacing
                });
            }
        }

        const chipDataOrder = [ ...redChipsSource, ...blueChipsSource ];

        for (let i = 0; i < positions.length; i++) {
            let chipData = chipDataOrder[i];

            if (chipData) {
                const newObjectChip = {
                    id: chipData.id, value: chipData.value, x: positions[i].x, y: positions[i].y,
                    vx: 0, vy: 0, radius: objectChipRadius, inPlay: true, color: chipData.color,
                    type: chipData.type, isPocketing: false, pocketingProgress: 0, pocketingHole: null,
                    rotation: 0, rotationSpeed: 0
                };
                chips.push(newObjectChip);
            }
        }
    } else if (gameMode.includes('61-ball')) {
        const chipColors = [
            null, '#FFD700', '#0000FF', '#FF0000', '#800080', '#FFA500', 
            '#008000', '#964B00', '#212121', '#FFC107', '#03A9F4', '#F44336', 
            '#9C27B0', '#FF9800', '#4CAF50', '#795548'
        ];

        let chipIds = Array.from({length: 15}, (_, i) => i + 1);

        const startX = canvas.width * 0.75;
        const startY = canvas.height / 2;
        const rowSpacing = objectChipRadius * 1.8;

        const rackPositions = [];
        for (let row = 0; row < 5; row++) {
            for (let col = 0; col <= row; col++) {
                rackPositions.push({
                    x: startX + row * rowSpacing,
                    y: startY + (col * objectChipRadius * 2.1) - (row * objectChipRadius * 1.05)
                });
            }
        }

        for (let i = 0; i < 15; i++) {
            const chipId = chipIds[i];
            const newObjectChip = {
                id: chipId, value: chipId, x: rackPositions[i].x, y: rackPositions[i].y,
                vx: 0, vy: 0, radius: objectChipRadius, inPlay: true,
                color: chipColors[chipId], type: 'numbered',
                isPocketing: false, pocketingProgress: 0, pocketingHole: null,
                rotation: 0, rotationSpeed: 0
            };
            chips.push(newObjectChip);
        }
    }
}

// =========================================================================
// DRAWING FUNCTIONS
// =========================================================================
function drawTable() {
    ctx.fillStyle = '#1a1a1a';
    holes.forEach(hole => {
        ctx.beginPath();
        ctx.arc(hole.x, hole.y, hole.radius, 0, Math.PI * 2);
        ctx.fill();
    });
    
    if (canvas.width > 0) {
        const fontSize = 60 * scale;
        ctx.font = `italic bold ${fontSize}px Georgia`;
        ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.textBaseline = 'middle';

        const spotX = canvas.width * (gameMode.includes('61-ball') ? 0.75 : 0.7);
        const spotY = canvas.height / 2;
        const spotRadius = BALL_RADIUS * scale;
        
        ctx.lineWidth = 3.5 * scale;
        ctx.beginPath();
        ctx.arc(spotX, spotY, spotRadius, 0, Math.PI * 2);
        ctx.stroke();

        const textPart1 = "P";
        const textPart2 = "ker";
        const spacing = 8 * scale;

        ctx.textAlign = 'right';
        ctx.fillText(textPart1, spotX - spotRadius - spacing, spotY);

        ctx.textAlign = 'left';
        ctx.fillText(textPart2, spotX + spotRadius + spacing, spotY);
        
        const pMetrics = ctx.measureText(textPart1);
        const kerMetrics = ctx.measureText(textPart2);
        const pokerWidth = pMetrics.width + (spacing * 2) + (spotRadius * 2) + kerMetrics.width;
        const pokerCenterX = (spotX - spotRadius - spacing - pMetrics.width) + (pokerWidth / 2);

        ctx.font = `italic bold ${fontSize}px Georgia`;
        ctx.textAlign = 'center';
        ctx.fillText("Pinoy Pool", (canvas.width / 2) - (60 * scale), 216 * scale);


    }
}

// PALITAN MO ANG BUONG drawChips FUNCTION MO NITO

function drawChips() {
    ctx.shadowColor = 'rgba(0, 0, 0, 0.4)';
    ctx.shadowBlur = 6 * scale;
    ctx.shadowOffsetX = 3 * scale;
    ctx.shadowOffsetY = 4 * scale;

    // Kunin ang naka-equip na chip theme
    const equippedChipSetId = playerProfile.equippedItems?.chips || 'default_chips';
    const currentTheme = ITEM_ASSETS.chips[equippedChipSetId];

    chips.forEach(chip => {
        if (chip.inPlay) {
            let displayRadius = chip.radius;
            if (chip.isPocketing) {
                displayRadius *= (1 - chip.pocketingProgress);
            }

            ctx.save();
            ctx.translate(chip.x, chip.y);
            
            if (chip.id === 0) { 
                // --- Pagguhit ng Tira (Cue Chip) ---
                ctx.beginPath();
                ctx.arc(0, 0, displayRadius, 0, Math.PI * 2);
                ctx.fillStyle = currentTheme.cue; // Galing na sa theme
                ctx.fill();

                ctx.strokeStyle = currentTheme.cueAccent; // Galing na sa theme
                ctx.lineWidth = 2 * scale;
                ctx.beginPath();
                ctx.arc(0, 0, displayRadius * 0.8, 0, Math.PI * 2);
                ctx.stroke();
                ctx.beginPath();
                ctx.arc(0, 0, displayRadius * 0.5, 0, Math.PI * 2);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.arc(0, 0, displayRadius * 0.2, 0, Math.PI * 2);
                ctx.fillStyle = currentTheme.cueCenter; // Galing na sa theme
                ctx.fill();

            } else { 
                // --- Pagguhit ng mga Panots (Object Chips) ---
                ctx.beginPath();
                ctx.arc(0, 0, displayRadius, 0, Math.PI * 2);
                ctx.fillStyle = currentTheme.base; // Galing na sa theme
                ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
                ctx.lineWidth = 1 * scale;
                ctx.fill();
                ctx.stroke();

                const innerRadius = displayRadius * 0.85;
                ctx.beginPath();
                ctx.arc(0, 0, innerRadius, 0, Math.PI * 2);
                // Pipiliin ang kulay base sa type ng bola at sa theme
                ctx.fillStyle = chip.type === 'red' ? currentTheme.red : currentTheme.blue;
                ctx.fill();
                
                if(chip.id) {
                    ctx.fillStyle = 'white';
                    ctx.font = `bold ${innerRadius * 1.7}px Arial, sans-serif`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.shadowColor = 'rgba(0,0,0,0.5)';
                    ctx.shadowBlur = 2 * scale;
                    ctx.shadowOffsetX = 1 * scale;
                    ctx.shadowOffsetY = 1 * scale;
                    ctx.fillText(chip.id, 0, 2 * scale);
                }
            }

            ctx.restore();
        }
    });

    ctx.shadowColor = 'transparent';
}

// IDAGDAG MO ITONG MGA BAGONG FUNCTIONS PARA SA SHOP

function openShop() {
    playButtonSound();
    // Tiyakin na updated ang data bago buksan ang shop
    getPlayerProfile(localPlayerUid).then(() => {
        gameModeSelect.style.display = 'none';
        shopModal.style.display = 'flex';
        history.pushState({ modal: 'shopModal' }, 'Shop', '#shop');
        playerCoinBalance.textContent = `${playerProfile.poolCoins.toLocaleString()} PC`;
        renderShopItems('cues'); // Ipakita muna ang Cues
    });
}

function renderShopItems(category) {
    shopItemsContainer.innerHTML = ''; // Linisin ang container

    // I-update ang active tab
    shopTabs.querySelectorAll('.shop-tab-button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.category === category);
    });

    const items = SHOP_ITEMS[category];
    items.forEach(item => {
        const itemDiv = document.createElement('div');
        itemDiv.className = 'shop-item';
        
        let buttonHTML = '';
        const isOwned = playerProfile.ownedItems.includes(item.id);
        const isEquipped = playerProfile.equippedItems[category.slice(0, -1)] === item.id;

        if (isEquipped) {
            buttonHTML = `<button class="shop-item-button equipped-button" disabled>Equipped</button>`;
        } else if (isOwned) {
            buttonHTML = `<button class="shop-item-button equip-button" data-item-id="${item.id}" data-item-type="${category.slice(0, -1)}">Equip</button>`;
        } else {
            buttonHTML = `<button class="shop-item-button buy-button" data-item-id="${item.id}" data-item-price="${item.price}" data-item-type="${category.slice(0, -1)}">Buy ${item.price.toLocaleString()} PC</button>`;
        }

        itemDiv.innerHTML = `
            <div class="shop-item-preview" style="background-image: url('${item.preview}')"></div>
            <div class="shop-item-name">${item.name}</div>
            ${buttonHTML}
        `;
        shopItemsContainer.appendChild(itemDiv);
    });
}

async function handleShopAction(e) {
console.log("SUCCESS: Na-click ang isang item sa shop!", e.target);
    const target = e.target;
    playButtonSound();

    if (target.classList.contains('buy-button')) {
        const itemId = target.dataset.itemId;
        const itemPrice = parseInt(target.dataset.itemPrice);
        const itemType = target.dataset.itemType;

        if (playerProfile.poolCoins >= itemPrice) {
            const playerDocRef = doc(db, "players", localPlayerUid);
            try {
                // Gamit ang transaction para iwas-error
                await runTransaction(db, async (transaction) => {
                    const sfDoc = await transaction.get(playerDocRef);
                    if (!sfDoc.exists()) { throw "Document does not exist!"; }
                    
                    const newCoins = sfDoc.data().poolCoins - itemPrice;
                    const newOwnedItems = [...sfDoc.data().ownedItems, itemId];

                    transaction.update(playerDocRef, { 
                        poolCoins: newCoins,
                        ownedItems: newOwnedItems
                    });
                });

                showMessage("Purchase successful!", 2000);
                // I-refresh ang shop para makita ang pagbabago
                await getPlayerProfile(localPlayerUid);
                playerCoinBalance.textContent = `${playerProfile.poolCoins.toLocaleString()} PC`;
                renderShopItems(itemType + 's');

            } catch (error) {
                console.error("Transaction failed: ", error);
                showMessage("Purchase failed. Please try again.", 3000);
            }
        } else {
            showMessage("Insufficient Pool Coins!", 3000);
        }

    } else if (target.classList.contains('equip-button')) {
        const itemId = target.dataset.itemId;
        const itemType = target.dataset.itemType;
        const playerDocRef = doc(db, "players", localPlayerUid);

        try {
            // I-update ang equipped item sa Firebase
            await updateDoc(playerDocRef, {
                [`equippedItems.${itemType}`]: itemId
            });

            showMessage(`${itemType.charAt(0).toUpperCase() + itemType.slice(1)} equipped!`, 2000);
            
            // I-refresh ulit ang shop
            await getPlayerProfile(localPlayerUid);
            renderShopItems(itemType + 's');

        } catch (error) {
            console.error("Equip failed: ", error);
            showMessage("Equip failed. Please try again.", 3000);
        }
    }
}

// Event Listeners para sa Shop
shopButton.addEventListener('click', openShop);
shopBackButton.addEventListener('click', () => {
    playButtonSound();
    shopModal.style.display = 'none';
    gameModeSelect.style.display = 'flex';
    history.back();
});
shopTabs.addEventListener('click', (e) => {
    if (e.target.classList.contains('shop-tab-button')) {
        playButtonSound();
        renderShopItems(e.target.dataset.category);
    }
});
shopItemsContainer.addEventListener('click', handleShopAction);




                function drawCueStick() {
    if (!cueStick.visible || !chips[0] || !chips[0].inPlay || !cueStickElement) return;

    const cueChip = chips[0];
    const canvasRect = canvas.getBoundingClientRect();
    const wrapperRect = gameWrapper.getBoundingClientRect();

    // Kinukuha natin ang actual na sukat ng tako image
    const stickWidth = cueStickElement.offsetWidth;
    const stickHeight = cueStickElement.offsetHeight;

    // Kinakalkula kung nasaan ang sentro ng puting bola
    const cueBallCenterX = canvasRect.left - wrapperRect.left + cueChip.x;
    const cueBallCenterY = canvasRect.top - wrapperRect.top + cueChip.y;

    // Itinatakda ang pwesto ng tako para ang DULO (tip) nito ang nasa sentro ng bola
    cueStickElement.style.left = `${cueBallCenterX - stickWidth}px`;
    cueStickElement.style.top = `${cueBallCenterY - (stickHeight / 2)}px`;

    // I-a-apply ang rotation at ang pag-urong (pullback)
    const pullbackPixels = -cueStick.pullback;
    // Sa loob ng drawCueStick() function
cueStickElement.style.transform = `rotate(${cueStick.angle}rad) translateX(${pullbackPixels - 15}px)`;

}



function drawGuidelines() {
    if (gameState !== 'aiming' || chipsMoving) return;
    
    const cueChip = chips[0];
    if (!cueChip || !cueChip.inPlay) return;

    const angle = cueStick.angle;
    const shotVector = { x: Math.cos(angle), y: Math.sin(angle) };
    let firstHit = null;
    let minCollisionDist = Infinity;

    for (const targetChip of chips) {
        if (targetChip.id === 0 || !targetChip.inPlay) continue;
        const cueToTarget = { x: targetChip.x - cueChip.x, y: targetChip.y - cueChip.y };
        const projDist = cueToTarget.x * shotVector.x + cueToTarget.y * shotVector.y;
        if (projDist <= 0) continue;
        const closestPointOnPath = { x: cueChip.x + projDist * shotVector.x, y: cueChip.y + projDist * shotVector.y };
        const perpDistSq = (closestPointOnPath.x - targetChip.x)**2 + (closestPointOnPath.y - targetChip.y)**2;
        const combinedRadiusSq = (cueChip.radius + targetChip.radius)**2;
        if (perpDistSq >= combinedRadiusSq) continue;
        const travelDist = projDist - Math.sqrt(combinedRadiusSq - perpDistSq);
        if (travelDist < minCollisionDist) {
            minCollisionDist = travelDist;
            firstHit = { chip: targetChip, travelDist: travelDist };
        }
    }
    
    ctx.setLineDash([5 * scale, 5 * scale]);
    ctx.lineWidth = 2.0 * scale; 

    if (firstHit) {
        const impactPoint = { x: cueChip.x + firstHit.travelDist * shotVector.x, y: cueChip.y + firstHit.travelDist * shotVector.y };
        
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.moveTo(cueChip.x, cueChip.y);
        ctx.lineTo(impactPoint.x, impactPoint.y);
        ctx.stroke();

        ctx.globalAlpha = 0.5; 
        ctx.beginPath();
        ctx.arc(impactPoint.x, impactPoint.y, cueChip.radius, 0, Math.PI * 2);
        ctx.fillStyle = '#FFD700'; 
        ctx.fill();
        ctx.strokeStyle = '#333333';
        ctx.lineWidth = 2 * scale;
        ctx.setLineDash([]); 
        ctx.stroke();
        ctx.globalAlpha = 1.0; 
        
        const objectChip = firstHit.chip;
        const collisionNormal = { x: objectChip.x - impactPoint.x, y: objectChip.y - impactPoint.y };
        const normMag = Math.sqrt(collisionNormal.x**2 + collisionNormal.y**2);
        const unitNormal = { x: collisionNormal.x / normMag, y: collisionNormal.y / normMag };
        ctx.strokeStyle = 'rgba(255, 255, 0, 0.9)';
        ctx.setLineDash([5 * scale, 5 * scale]); 
        ctx.beginPath();
        ctx.moveTo(objectChip.x, objectChip.y);
        ctx.lineTo(objectChip.x + unitNormal.x * 41, objectChip.y + unitNormal.y * 41);
        ctx.stroke();
        
        const tangentVector = { x: -unitNormal.y, y: unitNormal.x };
        if (tangentVector.x * shotVector.x + tangentVector.y * shotVector.y < 0) {
            tangentVector.x *= -1;
            tangentVector.y *= -1;
        }
        const sideSpinAngle = pektusOffset.x * 1.5;
        const followFactor = 1 - (pektusOffset.y * 0.8);
        const deflectedCueVector = {
            x: tangentVector.x * Math.cos(sideSpinAngle) - tangentVector.y * Math.sin(sideSpinAngle),
            y: tangentVector.x * Math.sin(sideSpinAngle) + tangentVector.y * Math.cos(sideSpinAngle)
        };
        const finalCueVector = {
            x: (deflectedCueVector.x * 0.7 + shotVector.x * 0.3) * followFactor,
            y: (deflectedCueVector.y * 0.7 + shotVector.y * 0.3) * followFactor
        };
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.moveTo(impactPoint.x, impactPoint.y);
        ctx.lineTo(impactPoint.x + finalCueVector.x * 2000, impactPoint.y + finalCueVector.y * 2000);
        ctx.stroke();

        let isWrongTarget = false;
        const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
        if (isMyTurn) {
            if (gameMode.includes('straight-ball') && colorsAssigned && playerChipsType) {
                if (firstHit.chip.type !== playerChipsType) {
                    isWrongTarget = true;
                }
            } else if (gameMode.includes('61-ball') && lowestChipNumber > 0) {
                if (firstHit.chip.id !== lowestChipNumber) {
                    isWrongTarget = true;
                }
            }
        }

        if (isWrongTarget) {
            ctx.save();
            ctx.font = `bold ${firstHit.chip.radius * 2}px Arial`;
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.shadowColor = 'rgba(0,0,0,0.5)';
            ctx.shadowBlur = 5 * scale;
            ctx.fillText('ðŸš«', firstHit.chip.x, firstHit.chip.y);
            ctx.restore();
        }

    } else {
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)';
        ctx.beginPath();
        ctx.moveTo(cueChip.x, cueChip.y);
        ctx.lineTo(cueChip.x + shotVector.x * 2000, cueChip.y + shotVector.y * 2000);
        ctx.stroke();
    }
    ctx.setLineDash([]);
}

// =========================================================================
// PHYSICS & COLLISION
// =========================================================================
function updateChipPositions() {
    const subSteps = 8;
    for (let i = 0; i < subSteps; i++) {
        chips.forEach(chip => { if (chip.inPlay && !chip.isPocketing) { chip.x += chip.vx/subSteps; chip.y += chip.vy/subSteps; }});
        for (let j = 0; j < chips.length; j++) {
            const chip1 = chips[j];
            if (!chip1.inPlay || chip1.isPocketing) continue;
            if (chip1.x + chip1.radius > canvas.width) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = canvas.width - chip1.radius; }
            if (chip1.x - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vx)); chip1.vx *= -1; chip1.x = chip1.radius; }
            if (chip1.y + chip1.radius > canvas.height) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = canvas.height - chip1.radius; }
            if (chip1.y - chip1.radius < 0) { playCushionSound(Math.abs(chip1.vy)); chip1.vy *= -1; chip1.y = chip1.radius; }
            for (let k = j + 1; k < chips.length; k++) {
                const chip2 = chips[k];
                if (chip2.inPlay && !chip2.isPocketing) handleChipCollision(chip1, chip2);
            }
        }
    }

    let stillMoving = false;
    chips.forEach(chip => {
        if (chip.inPlay) {
            if (chip.isPocketing) {
                chip.pocketingProgress += 0.05; chip.rotation += chip.rotationSpeed;
                chip.x += (chip.pocketingHole.x - chip.x) * 0.1; chip.y += (chip.pocketingHole.y - chip.y) * 0.1;
                if (chip.pocketingProgress >= 1) { chip.inPlay = false; chip.isPocketing = false; }
            } else {
                chip.vx *= FRICTION; chip.vy *= FRICTION;
                if (Math.abs(chip.vx) < MIN_VELOCITY) chip.vx = 0;
                if (Math.abs(chip.vy) < MIN_VELOCITY) chip.vy = 0;
                holes.forEach(hole => {
                    if (Math.sqrt((hole.x - chip.x)**2 + (hole.y - chip.y)**2) < hole.radius) {
                        playPocketSound();
                        chip.isPocketing = true; chip.pocketingHole = hole; chip.rotationSpeed = (Math.random() - 0.5) * 0.2;
                        chip.vx = 0; chip.vy = 0;
                        if (!chipsPocketedInTurn.find(p => p.id === chip.id)) chipsPocketedInTurn.push(chip);
                    }
                });
            }
            if (chip.vx !== 0 || chip.vy !== 0 || chip.isPocketing) stillMoving = true;
        }
    });
    
    chipsMoving = stillMoving;
    if (!chipsMoving) {
        if (gameState === 'shooting') {
            gameState = 'evaluating';
            if (!isOnlineGame || localPlayerUid === lastTurnControllerUid) {
                setTimeout(handleTurnEnd, 200);
            }
        }
    }
}

function handleChipCollision(chip1, chip2) {
    const dx = chip2.x - chip1.x, dy = chip2.y - chip1.y;
    const dist = Math.sqrt(dx*dx + dy*dy);
    const combinedRadius = chip1.radius + chip2.radius;
    if (dist < combinedRadius) {
        const impactSpeed = Math.sqrt((chip1.vx - chip2.vx)**2 + (chip1.vy - chip2.vy)**2);
        if (impactSpeed > 0.1) playCollisionSound(impactSpeed);
        if (firstChipHitInTurn === null) {
            if (chip1.id === 0) firstChipHitInTurn = chip2;
            else if (chip2.id === 0) firstChipHitInTurn = chip1;
        }
        const angle = Math.atan2(dy, dx), sin = Math.sin(angle), cos = Math.cos(angle);
        let vel1 = { x: chip1.vx * cos + chip1.vy * sin, y: chip1.vy * cos - chip1.vx * sin };
        let vel2 = { x: chip2.vx * cos + chip2.vy * sin, y: chip2.vy * cos - chip2.vx * sin };
        const vxTotal = vel1.x - vel2.x;
        vel1.x = ((chip1.radius - chip2.radius) * vel1.x + 2 * chip2.radius * vel2.x) / combinedRadius;
        vel2.x = vxTotal + vel1.x;
        const overlap = combinedRadius - dist;
        chip1.x -= (overlap / 2) * cos; chip1.y -= (overlap / 2) * sin;
        chip2.x += (overlap / 2) * cos; chip2.y += (overlap / 2) * sin;
        if (chip1.id === 0 || chip2.id === 0) {
            const sideSpin = shotPektusOffset.x * 0.5;
            vel1.y += sideSpin * Math.abs(vxTotal);
            if (shotPektusOffset.y < 0) {
                const followEnergy = Math.abs(vel1.x * shotPektusOffset.y * 0.2);
                vel1.x += followEnergy; vel2.x -= followEnergy;
            }
        }
        chip1.vx = vel1.x * cos - vel1.y * sin; chip1.vy = vel1.y * cos + vel1.x * sin;
        chip2.vx = vel2.x * cos - vel2.y * sin; 
        chip2.vy = vel2.y * cos + vel2.x * sin;
    }
}

// =========================================================================
// GAME LOGIC
// =========================================================================
function showMessage(msg, duration = 2000) {
    messageBox.textContent = msg;
    messageBox.style.display = 'block';
    setTimeout(() => { if (messageBox.textContent === msg) messageBox.style.display = 'none'; }, duration);
}

function resetChipStateForReturn(chip) {
    if (!chip) return;
    chip.inPlay = true;
    chip.isPocketing = false;
    chip.pocketingProgress = 0;
    chip.pocketingHole = null;
    chip.vx = 0;
    chip.vy = 0;
}

function startGame(mode, difficultyLevel = 'easy') {
    resizeCanvas(); 
    
    const allModals = [gameModeSelect, aiMenu, difficultySelect, straightBallInstructions, pokerInstructions, sixtyOneInstructions, onlineGameSelect, onlineMenu, waitingRoom, winnerModal, confirmExitModal, pokerFoulCardPickModal, leaderboardModal];
    allModals.forEach(modal => modal.style.display = 'none');
    gameMode = mode; isOnlineGame = false; difficulty = difficultyLevel;
    cueBallGuide.style.display = 'none'; 
    playerTurn = Math.random() < 0.5;
    canMoveCueBall = false; chipsMoving = false; colorsAssigned = false; 
    playerChipsType = null; opponentChipsType = null;
    setupChips();
    isBreakShot = true; canMoveCueBall = true; gameState = 'moving';
    cueStick.visible = true;
    
    if (playerTurn) {
        showMessage("You break! Place the cue ball.", 3000);
        dragGuideText.style.display = 'block'; 
    } else { 
        showMessage("Opponent breaks!", 3000); 
        placeCueChipForAI(); 
    }

    resetPektus();
    if (gameMode.includes('poker')) { createDeck(); dealCards(); updateCardDisplay(); } 
    else if (gameMode.includes('61-ball')) {
        player61Score = 0; opponent61Score = 0; lowestChipNumber = 1;
        cardHandContainer.style.display = 'none';
    }
    else cardHandContainer.style.display = 'none';
    updateInfoBox(); history.pushState({ modal: 'game' }, 'Game', '#game');
// ... bago mag-end ang startGame function
// Bumabati ang AI kung siya ang kalaban
if (gameMode.startsWith('ai')) {
    setTimeout(() => {
        aiDisplayMessage(getAiChatMessage('start'));
    }, 1500); // Maghihintay ng 1.5 segundo
}
updateInfoBox(); history.pushState({ modal: 'game' }, 'Game', '#game');
}



// =========================================================================
// TURN LOGIC - DUAL MODE
// =========================================================================
async function handleTurnEnd() {
    if (isOnlineGame && lastTurnControllerUid !== localPlayerUid) {
         return;
    }
    if (isProcessingTurnEnd) return;
    isProcessingTurnEnd = true;
    if (gameMode.includes('poker')) await handlePokerTurnEnd();
    else if (gameMode.includes('straight-ball')) await handleStraightBallTurnEnd();
    else if (gameMode.includes('61-ball')) await handle61BallTurnEnd();
    isProcessingTurnEnd = false;
}

// =========================================================================
// 61 BALL TURN LOGIC
// =========================================================================
// =================== PALITAN ANG BUONG handle61BallTurnEnd NITO ===================
async function handle61BallTurnEnd() {
    let foul = false;
    let switchTurn = true;
    const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
    const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);
    const lowestChipOnTable = lowestChipNumber;
    const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0);
    const didHitWrongBallFirst = !isBreakShot && firstChipHitInTurn && firstChipHitInTurn.id !== lowestChipOnTable;
    const didNotHitAnyBall = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0);

    if (wasCueBallPocketed || didHitWrongBallFirst || didNotHitAnyBall) {
        foul = true;
    }

    if (foul) {
        // AI REACTION FOR PLAYER'S FOUL
        if (isMyTurn && !isOnlineGame) {
            setTimeout(() => aiDisplayMessage(getAiChatMessage('playerFoul')), 800);
        }
        switchTurn = true;
        canMoveCueBall = true;
        const nextPlayerIsHuman = (!playerTurn && switchTurn) || (playerTurn && !switchTurn);
        if (nextPlayerIsHuman) {
            dragGuideText.style.display = 'block';
        }
        if (wasCueBallPocketed) {
            const cueChip = chips.find(c => c.id === 0);
            if (cueChip) {
                resetChipStateForReturn(cueChip);
                cueChip.x = canvas.width * 0.25; // Inayos para gamitin ang canvas.width
                cueChip.y = canvas.height / 2;     // Inayos para gamitin ang canvas.height
            }
        }
        if (pocketedObjectChips.length > 0) {
            pocketedObjectChips.forEach(chip => {
                const chipToReturn = chips.find(c => c.id === chip.id);
                if (chipToReturn) {
                    resetChipStateForReturn(chipToReturn);
                    placeChipOnSpot(chipToReturn);
                }
            });
        }
        if (isMyTurn) showMessage("Foul! Chips returned.", 2500);
    } else {
        if (pocketedObjectChips.length > 0) {
            const pointsThisTurn = pocketedObjectChips.reduce((sum, chip) => sum + chip.value, 0);
            if (isMyTurn) player61Score += pointsThisTurn;
            else opponent61Score += pointsThisTurn;
            switchTurn = false;
            // AI REACTION FOR PLAYER'S GOOD SHOT
            if (isMyTurn && !isOnlineGame) {
                setTimeout(() => aiDisplayMessage(getAiChatMessage('playerGoodShot')), 800);
            }
        } else {
            switchTurn = true;
        }
    }

    const newRemainingChips = chips.filter(c => c.inPlay && c.id !== 0);
    lowestChipNumber = newRemainingChips.length > 0 ? Math.min(...newRemainingChips.map(c => c.id)) : 0;
    const winner = checkWinCondition();
    if (winner) {
        const winnerText = (winner === 'player') ? 'You Win!' : (winner === 'opponent' ? 'You Lose!' : "It's a Draw! 60-60");
        await endGame(winnerText);
        return;
    }
    isBreakShot = false;
    if (isOnlineGame) await updateOnlineGameState(switchTurn);
    else updateLocalGameState(switchTurn);
}


// =========================================================================
// POKER TURN LOGIC
// =========================================================================
function waitForCardPick() {
    return new Promise(resolve => {
        pokerFoulCardPickModal.style.display = 'flex';
        pokerFoulCardsContainer.innerHTML = '';
        const cardsToDraw = [];
        for (let i = 0; i < 5; i++) if (deck.length > 0) cardsToDraw.push(deck.splice(Math.floor(Math.random() * deck.length), 1)[0]);
        if (cardsToDraw.length === 0) { pokerFoulCardPickModal.style.display = 'none'; resolve(null); return; }
        cardsToDraw.forEach(card => {
            const cardDiv = document.createElement('div');
            cardDiv.className = 'card face-down';
            cardDiv.onclick = () => {
                playButtonSound();
                cardDiv.classList.remove('face-down');
                const color = (card.suit === 'â™¥' || card.suit === 'â™¦') ? '#ff5555' : 'white';
                cardDiv.innerHTML = `<span class="card-rank" style="color: ${color};">${card.rank}</span><span class="card-suit" style="color: ${color};">${card.suit}</span>`;
                pokerFoulCardsContainer.querySelectorAll('.card').forEach(c => { c.onclick = null; c.style.cursor = 'default'; });
                setTimeout(() => {
                    pokerFoulCardPickModal.style.display = 'none';
                    cardsToDraw.forEach(c => { if (c !== card) deck.push(c); });
                    resolve(card);
                }, 1500);
            };
            pokerFoulCardsContainer.appendChild(cardDiv);
        });
    });
}

// =================== PALITAN ANG BUONG handlePokerTurnEnd NITO ===================
async function handlePokerTurnEnd() {
    const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
    const currentHand = isMyTurn ? playerHand : opponentHand;
    const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);
    const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0);
    const didHitNothing = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0);
    const legallyPocketedOwnChips = pocketedObjectChips.filter(chip => currentHand.some(card => card.value === chip.id));
    const illegallyPocketedChips = pocketedObjectChips.filter(chip => !currentHand.some(card => card.value === chip.id));
    let switchTurn = true;
    let foul = wasCueBallPocketed || didHitNothing;

    if (legallyPocketedOwnChips.length > 0 && illegallyPocketedChips.length === 0 && !foul) {
        switchTurn = false;
        // AI REACTION FOR PLAYER'S GOOD SHOT
        if (isMyTurn && !isOnlineGame) {
            setTimeout(() => aiDisplayMessage(getAiChatMessage('playerGoodShot')), 800);
        }
    }
    
    if (pocketedObjectChips.length > 0) {
        const pocketedIds = pocketedObjectChips.map(c => c.id);
        playerHand = playerHand.filter(card => !pocketedIds.includes(card.value));
        opponentHand = opponentHand.filter(card => !pocketedIds.includes(card.value));
    }

    if (foul) {
        // AI REACTION FOR PLAYER'S FOUL
        if (isMyTurn && !isOnlineGame) {
            setTimeout(() => aiDisplayMessage(getAiChatMessage('playerFoul')), 800);
        }
        canMoveCueBall = true;
        const nextPlayerIsHuman = (!playerTurn && switchTurn) || (playerTurn && !switchTurn);
        if (nextPlayerIsHuman) {
            dragGuideText.style.display = 'block';
        }
        if (wasCueBallPocketed) {
            const cueChip = chips.find(c => c.id === 0);
            if (cueChip) {
                resetChipStateForReturn(cueChip);
                cueChip.x = canvas.width * 0.25; // Inayos para gamitin ang canvas.width
                cueChip.y = canvas.height / 2;     // Inayos para gamitin ang canvas.height
            }
            if(isMyTurn) showMessage("Foul! You scratched.", 3000);
            let newCard = isMyTurn ? await waitForCardPick() : (deck.length > 0 ? deck.splice(Math.floor(Math.random() * deck.length), 1)[0] : null);
            if (newCard) {
                const cardName = `${newCard.rank}${newCard.suit}`;
                const correspondingChip = chips.find(c => c.id === newCard.value);
                if (correspondingChip && !correspondingChip.inPlay) {
                     if (isMyTurn) showMessage(`You picked ${cardName}, but it was pocketed. Card discarded.`, 3000);
                } else {
                    (isMyTurn ? playerHand : opponentHand).push(newCard);
                    if (isMyTurn) showMessage(`Foul! You picked ${cardName}.`, 3000);
                }
                if (playerHand.length === 1 && newCard.rank === 'K' && wasCueBallPocketed && legallyPocketedOwnChips.length > 0) {
                    await endGame('You Win on a Lucky Scratch!', playerHand, opponentHand);
                    return;
                }
            }
        }
    }
    
    const winner = checkWinCondition();
    if (winner) {
        const winnerText = (winner === 'player') ? 'You Win!' : 'You Lose!';
        await endGame(winnerText, playerHand, opponentHand);
        return;
    }
    isBreakShot = false;
    if (isOnlineGame) await updateOnlineGameState(switchTurn);
    else updateLocalGameState(switchTurn);
}


// =========================================================================
// STRAIGHT BALL TURN LOGIC

// =================== PALITAN ANG BUONG handleStraightBallTurnEnd NITO ===================
async function handleStraightBallTurnEnd() {
    let foul = false, switchTurn = true, foulReason = "";
    const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
    const pocketedObjectChips = chipsPocketedInTurn.filter(c => c.id !== 0);
    const currentPlayerColor = isMyTurn ? playerChipsType : opponentChipsType;
    const wasCueBallPocketed = chipsPocketedInTurn.some(c => c.id === 0);
    const didHitWrongBallFirst = !isBreakShot && colorsAssigned && firstChipHitInTurn && firstChipHitInTurn.type !== currentPlayerColor;
    const didNotHitAnyBall = firstChipHitInTurn === null && chips.some(c => c.inPlay && c.id !== 0);

    if (wasCueBallPocketed || didHitWrongBallFirst || didNotHitAnyBall) {
        foul = true;
    }

    if (pocketedObjectChips.length > 0) {
        if (!colorsAssigned && !foul) {
            const firstPocketed = pocketedObjectChips[0];
            if (isMyTurn) {
                playerChipsType = firstPocketed.type;
                opponentChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
            } else {
                opponentChipsType = firstPocketed.type;
                playerChipsType = firstPocketed.type === 'red' ? 'blue' : 'red';
            }
            colorsAssigned = true;
            if (isMyTurn) showMessage(`Colors assigned! You are ${playerChipsType}.`, 3000);
        }
        const myPocketedCount = pocketedObjectChips.filter(c => c.type === (isMyTurn ? playerChipsType : opponentChipsType)).length;
        const opponentPocketedCount = pocketedObjectChips.filter(c => c.type === (isMyTurn ? opponentChipsType : playerChipsType)).length;
        
        if (!foul && myPocketedCount > 0 && opponentPocketedCount === 0) {
            switchTurn = false;
            // AI REACTION FOR PLAYER'S GOOD SHOT
            if (isMyTurn && !isOnlineGame) {
                setTimeout(() => aiDisplayMessage(getAiChatMessage('playerGoodShot')), 800);
            }
        }
    }

    if (foul) {
        // AI REACTION FOR PLAYER'S FOUL
        if (isMyTurn && !isOnlineGame) {
            setTimeout(() => aiDisplayMessage(getAiChatMessage('playerFoul')), 800);
        }
        switchTurn = true;
        canMoveCueBall = true;
        const nextPlayerIsHuman = (!playerTurn && switchTurn) || (playerTurn && !switchTurn);
        if (nextPlayerIsHuman) {
            dragGuideText.style.display = 'block';
        }
        if (wasCueBallPocketed) {
            foulReason += "Cue ball pocketed! ";
            const cueChip = chips.find(c => c.id === 0);
            if (cueChip) {
                resetChipStateForReturn(cueChip);
                cueChip.x = canvas.width * 0.25; // Inayos para gamitin ang canvas.width
                cueChip.y = canvas.height / 2;     // Inayos para gamitin ang canvas.height
            }
            const foulingPlayerColor = isMyTurn ? playerChipsType : opponentChipsType;
            if (foulingPlayerColor) {
                const chipToReturn = chips.find(c => c.type === foulingPlayerColor && !c.inPlay && !chipsPocketedInTurn.some(p => p.id === c.id));
                if (chipToReturn) {
                    resetChipStateForReturn(chipToReturn);
                    placeChipOnSpot(chipToReturn);
                    foulReason += "One of your balls was returned.";
                }
            }
        }
        if (didHitWrongBallFirst) {
            foulReason += "Hit opponent's ball first. ";
            const myPocketedInFoul = pocketedObjectChips.filter(c => c.type === currentPlayerColor);
            if (myPocketedInFoul.length > 0) {
                foulReason += "Your pocketed balls are returned.";
                myPocketedInFoul.forEach(pc => {
                    const foundChip = chips.find(c => c.id === pc.id);
                    if (foundChip) {
                        resetChipStateForReturn(foundChip);
                        placeChipOnSpot(foundChip);
                    }
                });
            }
        }
        if (didNotHitAnyBall) foulReason += "No object ball was hit. ";
    }
    
    if (foulReason && isMyTurn) showMessage("Foul! " + foulReason.trim(), 4000);
    const winner = checkWinCondition();
    if (winner) {
        await endGame((winner === 'player') ? 'You Win!' : 'You Lose!');
        return;
    }
    isBreakShot = false;
    if (isOnlineGame) await updateOnlineGameState(switchTurn);
    else updateLocalGameState(switchTurn);
}



// vvvv PALITAN MO ANG BUONG FUNCTION NITO vvvv

async function updateOnlineGameState(switchTurn) {
    try {
        const gameDocRef = doc(db, "games", gameId);
        const docSnap = await getDoc(gameDocRef);
        if (!docSnap.exists() || docSnap.data().gameState === 'finished') return;

        let nextTurnUid = docSnap.data().currentTurnUid;
        if (switchTurn) {
            nextTurnUid = (nextTurnUid === docSnap.data().players.player1.uid) ? docSnap.data().players.player2.uid : docSnap.data().players.player1.uid;
        }
        
        // ITO ANG MAHALAGANG PAG-AAYOS:
        // Dapat laging canvas.width at canvas.height ang basehan kapag sine-send online
        const chipsToSend = chips.map(c => ({...c, x: c.x / canvas.width, y: c.y / canvas.height }));
        const newTurnId = (docSnap.data().turnId || 0) + 1;

        const updatedData = { 
            chips: chipsToSend, 
            currentTurnUid: nextTurnUid, 
            canMoveCueBall, 
            isBreakShot: false, 
            turnInProgress: false,
            turnId: newTurnId, 
            liveAimData: null 
        };

        if (gameMode.includes('poker')) {
            const hands = (localPlayerId === 'player1') ? { player1Hand: playerHand, player2Hand: opponentHand } : { player1Hand: opponentHand, player2Hand: playerHand };
            Object.assign(updatedData, { deck }, hands);
        } else if (gameMode.includes('straight-ball')) {
            const types = (localPlayerId === 'player1') ? { player1ChipsType: playerChipsType, player2ChipsType: opponentChipsType } : { player1ChipsType: opponentChipsType, player2ChipsType: playerChipsType };
            Object.assign(updatedData, { colorsAssigned }, types);
        } else if (gameMode.includes('61-ball')) {
            const scores = (localPlayerId === 'player1') ? { player1_61Score: player61Score, player2_61Score: opponent61Score } : { player1_61Score: opponent61Score, player2_61Score: player61Score };
            Object.assign(updatedData, { lowestChipNumber }, scores);
        }

        await updateDoc(gameDocRef, updatedData);
    } catch (error) { console.error("Error updating game state:", error); showMessage("Connection error.", 3000); }
}

function updateLocalGameState(switchTurn) {
    if (switchTurn) {
        if (!playerTurn && chipsPocketedInTurn.length > 0) {
             setTimeout(() => { aiDisplayMessage(getAiChatMessage('playerGoodShot')); }, 700);
        }
        playerTurn = !playerTurn;
        if (playerTurn) {
            aiConsecutivePots = 0;
        }
        showMessage(`${playerTurn ? 'Your' : 'Opponent'}'s turn`, 1500);
    } else {
        if (playerTurn) {
            showMessage("You shoot again!", 1500);
        } else {
            aiConsecutivePots++;
            showMessage("AI shoots again!", 1500);
            setTimeout(() => { aiDisplayMessage(getAiChatMessage('goodShot')); }, 700);
        }
    }

    chipsPocketedInTurn = [];
    firstChipHitInTurn = null;
    resetPektus();
    updateCardDisplay();
    updateInfoBox();
    
    if (gameState !== 'gameover') {
        if (canMoveCueBall) {
            gameState = 'moving';
            if (gameMode.includes('ai') && !playerTurn) {
                placeCueChipForAI();
            }
        } else {
            gameState = 'aiming';
            cueStick.visible = true;
            if (cueStickElement) cueStickElement.style.display = 'block'; // Ito yung line para sa tako
            if (gameMode.includes('ai') && !playerTurn) {
                setTimeout(aiTurn, 1000);
            }
        }
    }
}




function checkWinCondition() {
    if (gameState === 'gameover') return null;
    let winner = null;
    if (gameMode.includes('poker')) {
        if (playerHand.length === 0 || (playerHand.length > 0 && playerHand.every(card => card.rank === 'K'))) winner = 'player';
        else if (opponentHand.length === 0 || (opponentHand.length > 0 && opponentHand.every(card => card.rank === 'K'))) winner = 'opponent';
    } else if (gameMode.includes('straight-ball') && colorsAssigned) {
        if (!chips.some(c => c.inPlay && c.type === playerChipsType) && playerChipsType) winner = 'player';
        else if (!chips.some(c => c.inPlay && c.type === opponentChipsType) && opponentChipsType) winner = 'opponent';
    } else if (gameMode.includes('61-ball')) {
        if (player61Score >= 61) winner = 'player';
        else if (opponent61Score >= 61) winner = 'opponent';
        else if (!chips.some(c => c.inPlay && c.id !== 0) && player61Score === 60 && opponent61Score === 60) winner = 'draw';
    }
    return winner;
}

async function shoot(shotPower) {
    if (gameState !== 'aiming' || chipsMoving) return;

    playCueHitSound((shotPower - 5) / 30);

    chipsPocketedInTurn = [];
    firstChipHitInTurn = null;
    shotPektusOffset = { ...pektusOffset };
    
    const shotData = { 
        uid: localPlayerUid, 
        angle: cueStick.angle, 
        power: shotPower, 
        pektus: shotPektusOffset, 
        timestamp: Date.now() 
    };
    
    cueStick.power = 0;
    powerBar.style.height = '0%';
    
    gameState = 'shooting_animation';
    let startTime = null;
    const animationDuration = 100;
    const startPullback = cueStick.pullback;
    const endPullback = -30 * scale;
    
    function animateLocalShot(timestamp) {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / animationDuration, 1);
        cueStick.pullback = startPullback + (endPullback - startPullback) * progress;

        if (progress < 1) {
            requestAnimationFrame(animateLocalShot);
        } else {
            cueStick.pullback = 0;
            cueStick.visible = false;
            cueStickElement.style.display = 'none';
            if (isOnlineGame) {
                try {
                    lastTurnControllerUid = localPlayerUid;
                    updateDoc(doc(db, "games", gameId), { lastShot: shotData, turnInProgress: true, lastTurnController: localPlayerUid });
                } catch (error) {
                    console.error("Error sending shot data:", error);
                    gameState = 'aiming'; 
                    cueStick.visible = true;
                }
            } else {
                applyShot(shotData);
            }
        }
    }
    requestAnimationFrame(animateLocalShot);
}

function applyShot(shotData) {
    if (chipsMoving) return; 
    const cueChip = chips[0];
    if (!cueChip || !cueChip.inPlay) return;
    shotPektusOffset = shotData.pektus || { x: 0, y: 0 };
    cueChip.vx = Math.cos(shotData.angle) * shotData.power * scale;
    cueChip.vy = Math.sin(shotData.angle) * shotData.power * scale;
    chipsMoving = true; 
    gameState = 'shooting';
    if (isOnlineGame) {
        lastTurnControllerUid = shotData.uid;
    }
}

// PALITAN MO ANG BUONG endGame FUNCTION MO NITO:

async function endGame(winnerTextMessage, finalPlayerHand, finalOpponentHand) {
    if (gameMode.startsWith('ai')) {
        const playerWon = winnerTextMessage.includes('You Win');
        setTimeout(() => {
            aiDisplayMessage(getAiChatMessage(playerWon ? 'lose' : 'win'));
        }, 1000);
    }

    if (gameState === 'gameover') return;
    gameState = 'gameover';
    
    const rematchButton = document.getElementById('rematch-button');
    const playAgainButton = document.getElementById('play-again-button');

    if (isOnlineGame) {
        rematchButton.style.display = 'block';
        rematchButton.textContent = 'Rematch';
        rematchButton.disabled = false;
        playAgainButton.style.display = 'none';
    } else {
        rematchButton.style.display = 'none';
        playAgainButton.style.display = 'block';
    }

    const playerWonLocally = winnerTextMessage.includes('You Win');
    const pHand = finalPlayerHand || playerHand;
    const oHand = finalOpponentHand || opponentHand;

    if (isOnlineGame) {
        try {
            const gameDocRef = doc(db, "games", gameId);
            const docSnap = await getDoc(gameDocRef);
            if (docSnap.exists() && docSnap.data().gameState !== 'finished') {
                let winnerUid = null;
                const { player1, player2 } = docSnap.data().players;
                if (winnerTextMessage.includes('You Win')) {
                    winnerUid = localPlayerUid;
                } else if (winnerTextMessage.includes('Lose') || winnerTextMessage.includes('Opponent')) {
                    winnerUid = localPlayerUid === player1.uid ? player2.uid : player1.uid;
                }
                
                const finalPayload = {};
                if (gameMode.includes('poker')) {
                    const hands = (localPlayerId === 'player1') 
                        ? { player1Hand: pHand, player2Hand: oHand } 
                        : { player1Hand: oHand, player2Hand: pHand };
                    Object.assign(finalPayload, hands);
                }

                if (winnerUid) {
                    await updateDoc(gameDocRef, { 
                        gameState: 'finished', 
                        winner: winnerUid, 
                        turnInProgress: false,
                        ...finalPayload
                    });
                }
                
                if (winnerUid === localPlayerUid) await updatePlayerData(localPlayerUid, true);
            }
        } catch (e) { console.error("Failed to process final game state:", e); }
    } else if (playerWonLocally) {
        await updatePlayerData(localPlayerUid, true);
    } 
    // ITO ANG BAGONG DAGDAG PARA SA CONSOLATION PRIZE
    else if (!isOnlineGame && gameState !== 'menu') {
        await updatePlayerData(localPlayerUid, false); 
        const playerDocRef = doc(db, "players", localPlayerUid);
        await updateDoc(playerDocRef, { poolCoins: increment(CONSOLATION_REWARD) });
        showMessage(`You earned ${CONSOLATION_REWARD} PC for playing!`, 2500);
    }

    let finalWinnerTextHTML = winnerTextMessage;
    if (gameMode.includes('61-ball')) {
        finalWinnerTextHTML += `<p style="font-size: 0.7em; color: #f0f0f0; margin-top: 20px; font-weight: normal;">Final Score<br>You: ${player61Score} - Opponent: ${opponent61Score}</p>`;
    }
    winnerText.innerHTML = finalWinnerTextHTML;

    if (gameMode.includes('poker')) {
        const opponentActualHand = oHand;
        const opponentActualOriginalHand = originalOpponentHand;

        const pocketedHandToShow = opponentActualOriginalHand.filter(oCard => 
            !opponentActualHand.some(rCard => rCard.rank === oCard.rank && rCard.suit === oCard.suit)
        );
        
        const createCardDisplay = (title, hand) => {
            if (!hand || hand.length === 0) return '';
            let html = `<h3>${title}</h3><div style="display: flex; gap: 5px; justify-content: center;">`;
            hand.forEach(card => {
                const color = (card.suit === 'â™¥' || card.suit === 'â™¦') ? '#ff5555' : 'white';
                html += `<div class="card" style="transform: scale(0.8);"><span class="card-rank" style="color: ${color};">${card.rank}</span><span class="card-suit" style="color: ${color};">${card.suit}</span></div>`;
            });
            return html + `</div>`;
        };
        opponentHandReveal.innerHTML = createCardDisplay("Opponent's Pocketed Cards:", pocketedHandToShow) + createCardDisplay("Opponent's Remaining Cards:", opponentActualHand);
    } else {
        opponentHandReveal.innerHTML = ''; 
    }
    
    winnerModal.style.display = 'flex';
    history.pushState({ modal: 'winner' }, 'Winner', '#winner');
}

async function handleRematchRequest() {
    if (!isOnlineGame || !gameId) return;

    const rematchButton = document.getElementById('rematch-button');
    rematchButton.disabled = true;
    rematchButton.textContent = 'Waiting for Opponent...';

    const gameDocRef = doc(db, "games", gameId);
    try {
        await updateDoc(gameDocRef, {
            [`rematchRequest.${localPlayerUid}`]: true
        });
    } catch (error) {
        console.error("Error sending rematch request:", error);
        rematchButton.textContent = 'Error! Try Again';
        rematchButton.disabled = false;
    }
}

// PALITAN MO ANG BUONG updatePlayerData FUNCTION NITO
async function updatePlayerData(uid, didWin = false) {
    if (!uid) return;
    const playerDocRef = doc(db, "players", uid);
    
    try {
        const playerDoc = await getDoc(playerDocRef);
        
        // Kung manalo, i-increment ang wins at poolCoins
        const dataToUpdate = didWin 
            ? { wins: increment(1), poolCoins: increment(WIN_REWARD), lastPlayed: serverTimestamp() }
            : { lastPlayed: serverTimestamp() };

        if (!playerDoc.exists() || !playerDoc.data().displayName) {
            let displayName = localStorage.getItem('pinoyPoolPlayerName');
            if (!displayName) {
                displayName = prompt("Congratulations! Enter your name for the leaderboard:", "Player" + Math.floor(Math.random() * 1000));
                if (!displayName || displayName.trim() === "") displayName = "Anonymous";
                localStorage.setItem('pinoyPoolPlayerName', displayName);
            }
            
            // I-set ang initial data kasama ang panalo
            const initialData = {
                displayName: displayName,
                wins: didWin ? 1 : 0,
                poolCoins: didWin ? WIN_REWARD : 0,
                ownedItems: ['default_cue', 'default_table', 'default_chips'],
                equippedItems: { cue: 'default_cue', table: 'default_table', chips: 'default_chips' },
                lastPlayed: serverTimestamp()
            };
            await setDoc(playerDocRef, initialData);

        } else {
            // I-update lang ang existing player
            await updateDoc(playerDocRef, dataToUpdate);
        }
    } catch (error) { console.error("Error updating player data:", error); }
}


// =================== SIMULA NG IPAPALIT MO (KOPYAHIN LAHAT ITO) ===================

// Ito yung bagong function na para lang sa pag-delete sa database
async function cleanupMatchmakingEntry() {
    if (unsubscribeFromQueue) {
        unsubscribeFromQueue();
        unsubscribeFromQueue = null;
    }
    
    const queueCollection = collection(db, "matchmakingQueue");
    const q = query(queueCollection, where("uid", "==", localPlayerUid));
    const snapshot = await getDocs(q);
    if (!snapshot.empty) {
        const myDocRef = snapshot.docs[0].ref;
        await deleteDoc(myDocRef);
    }
}

// Ito yung function para sa "Cancel" button, na tinatawag yung bagong function sa taas
async function cancelMatchmaking() {
    if (matchmakingTimeoutId) {
        clearTimeout(matchmakingTimeoutId);
        matchmakingTimeoutId = null;
    }
    
    await cleanupMatchmakingEntry(); // Ginagamit na niya yung bagong function

    matchmakingWaitModal.style.display = 'none';
    onlineMenu.style.display = 'flex';
    history.back();
    
    showMessage("Matchmaking cancelled.");
}

// Ito yung kumpletong findMatch function na inaayos ang lahat
async function findMatch() {
    if (!isAuthReady || !localPlayerUid) {
        showMessage("Connecting... Please wait.");
        return;
    }

    onlineMenu.style.display = 'none';
    matchmakingWaitModal.style.display = 'flex';
    history.pushState({ modal: 'matchmaking' }, 'Matchmaking', '#matchmaking');
    
    matchmakingTimeoutId = setTimeout(async () => {
        if (gameId) {
            clearTimeout(matchmakingTimeoutId);
            return;
        }

        console.log("Matchmaking timed out. Falling back to AI.");
        
        await cleanupMatchmakingEntry(); // GINAGAMIT NA RIN NIYA ANG TAMANG FUNCTION
        
        matchmakingWaitModal.style.display = 'none';
        showMessage("No opponents found. Starting game vs AI...", 2500);

        setTimeout(() => {
            const fallbackGameMode = `ai-${selectedOnlineGameType}`;
            startGame(fallbackGameMode, 'hard');
        }, 1000);

    }, 15000);

    const queueCollection = collection(db, "matchmakingQueue");
    
    const myQueueDocRef = await addDoc(queueCollection, {
        uid: localPlayerUid,
        gameType: selectedOnlineGameType,
        status: 'waiting',
        timestamp: serverTimestamp()
    });

    unsubscribeFromQueue = onSnapshot(myQueueDocRef, (doc) => {
        const data = doc.data();
        if (data && data.status === 'matched' && data.gameId) {
            clearTimeout(matchmakingTimeoutId);
            if (unsubscribeFromQueue) unsubscribeFromQueue();
            matchmakingWaitModal.style.display = 'none';
            showMessage("Opponent found! Joining game...");
            gameId = data.gameId;
            localPlayerId = 'player2';
            listenToGameUpdates(gameId);
        }
    });

    const q = query(
        queueCollection,
        where("status", "==", "waiting"),
        where("gameType", "==", selectedOnlineGameType),
        where("uid", "!=", localPlayerUid),
        limit(1)
    );

    const availableOpponents = await getDocs(q);

    if (!availableOpponents.empty) {
        clearTimeout(matchmakingTimeoutId);
        
        const opponentDoc = availableOpponents.docs[0];
        const opponentDocRef = opponentDoc.ref;
        const opponentUid = opponentDoc.data().uid;

        try {
            await runTransaction(db, async (transaction) => {
                const freshOpponentDoc = await transaction.get(opponentDocRef);
                if (!freshOpponentDoc.exists() || freshOpponentDoc.data().status !== 'waiting') {
                    throw "Opponent is no longer available.";
                }
                
                gameId = Math.random().toString(36).substring(2, 7).toUpperCase();
                 
                localPlayerId = 'player1';
                gameMode = `online-${selectedOnlineGameType}`;
                resizeCanvas();
                setupChips(); 
                const initialChipsToSend = chips.map(c => ({...c, x: c.x/canvas.width, y: c.y/canvas.height }));
                const startingPlayerUid = Math.random() < 0.5 ? localPlayerUid : opponentUid;
                
                let gameData = { 
                    gameId, gameType: selectedOnlineGameType, gameState: 'playing', turnId: 1, 
                    players: { player1: { uid: localPlayerUid, status: 'online' }, player2: { uid: opponentUid, status: 'online' } }, 
                    chips: initialChipsToSend, currentTurnUid: startingPlayerUid,
                    lastShot: null, liveAimData: null, turnInProgress: false, 
                    canMoveCueBall: true, isBreakShot: true, winner: null
                };

                if (selectedOnlineGameType === 'poker') {
                    createDeck(); dealCards();
                    Object.assign(gameData, { deck, player1Hand: playerHand, player2Hand: opponentHand, originalPlayer1Hand: originalPlayerHand, originalPlayer2Hand: originalOpponentHand });
                } else if (selectedOnlineGameType === 'straight-ball') {
                    Object.assign(gameData, { colorsAssigned: false, player1ChipsType: null, player2ChipsType: null });
                } else if (selectedOnlineGameType === '61-ball') {
                    Object.assign(gameData, { player1_61Score: 0, player2_61Score: 0, lowestChipNumber: 1 });
                }

                const gameDocRef = doc(db, "games", gameId);
                transaction.set(gameDocRef, gameData);
                transaction.update(opponentDocRef, { status: 'matched', gameId: gameId });
                transaction.update(myQueueDocRef, { status: 'matched', gameId: gameId });
            });

            if (unsubscribeFromQueue) unsubscribeFromQueue();
            matchmakingWaitModal.style.display = 'none';
            showMessage("Opponent found! Starting game...");
            listenToGameUpdates(gameId);

        } catch (e) {
            console.error("Matchmaking failed: ", e);
            showMessage("Matchmaking failed. Trying again...");
            if (matchmakingTimeoutId) clearTimeout(matchmakingTimeoutId);
            cancelMatchmaking();
        }
    }
}

// =================== DULO NG IPAPALIT MO ===================



        // =========================================================================
// == GOD-TIER AI v16 (KUMPLETONG BERSYON - SEPT 25, 2025) ==
// =========================================================================

/**
 * HELPER: Tinitingnan kung may bolang nakaharang sa isang linya. (VERSION 2 with SAFETY MARGIN)
 */
function isPathObstructed(startObj, endObj, ignoreChipIds = []) {
    const allObstacles = chips.filter(c => c.inPlay && !ignoreChipIds.includes(c.id));
    
    for (const obstacle of allObstacles) {
        const dist = Math.abs((endObj.y - startObj.y) * obstacle.x - (endObj.x - startObj.x) * obstacle.y + endObj.x * startObj.y - endObj.y * startObj.x) / Math.hypot(endObj.y - startObj.y, endObj.x - startObj.x);
        
        const safetyMargin = 4 * scale;

        const effectiveRadius = obstacle.radius + (startObj.radius || 0) + safetyMargin;

        if (dist < effectiveRadius) {
            const dotProduct = (obstacle.x - startObj.x) * (endObj.x - startObj.x) + (obstacle.y - startObj.y) * (endObj.y - startObj.y);
            const squaredLength = Math.pow(Math.hypot(endObj.x - startObj.x, endObj.y - startObj.y), 2);
            if (dotProduct > 0 && dotProduct < squaredLength) {
                return true;
            }
        }
    }
    return false;
}

function isAnyDirectPathClear(cueChip, legalTargets) {
    if (!legalTargets || legalTargets.length === 0) return false;
    for (const target of legalTargets) {
        if (!isPathObstructed(cueChip, target, [])) return true;
    }
    return false;
}

function evaluateShot(cueChip, targetChip, hole, allLegalTargets, difficulty, isCombination = false) {
    let firstContactTarget = isCombination ? allLegalTargets[0] : targetChip;
    if (!firstContactTarget) return null;

    const cushionSize = 38 * scale;
    const aiTargetHole = {
        x: (hole.x < canvas.width / 2) ? cushionSize : canvas.width - cushionSize,
        y: (hole.y < canvas.height / 2) ? cushionSize : canvas.height - cushionSize
    };

    let shotAngle;
    if (isCombination) {
        const impactAngle1 = Math.atan2(aiTargetHole.y - targetChip.y, aiTargetHole.x - targetChip.x);
        const pfm = { x: targetChip.x - Math.cos(impactAngle1) * (firstContactTarget.radius + targetChip.radius), y: targetChip.y - Math.sin(impactAngle1) * (firstContactTarget.radius + targetChip.radius) };
        const impactAngle2 = Math.atan2(pfm.y - firstContactTarget.y, pfm.x - firstContactTarget.x);
        const gbfc = { x: firstContactTarget.x - Math.cos(impactAngle2) * (cueChip.radius + firstContactTarget.radius), y: firstContactTarget.y - Math.sin(impactAngle2) * (cueChip.radius + firstContactTarget.radius) };
        shotAngle = Math.atan2(gbfc.y - cueChip.y, gbfc.x - cueChip.x);
    } else {
        const targetToHoleAngle = Math.atan2(aiTargetHole.y - targetChip.y, aiTargetHole.x - targetChip.x);
        const ghostBall = {
            x: targetChip.x - Math.cos(targetToHoleAngle) * (cueChip.radius + targetChip.radius),
            y: targetChip.y - Math.sin(targetToHoleAngle) * (cueChip.radius + targetChip.radius)
        };
        shotAngle = Math.atan2(ghostBall.y - cueChip.y, ghostBall.x - cueChip.x);
    }
    
    const path1Clear = !isPathObstructed(cueChip, firstContactTarget, [targetChip.id]);
    const path2Clear = !isPathObstructed(targetChip, hole, [cueChip.id, firstContactTarget.id]);
    let path3Clear = !isCombination || !isPathObstructed(firstContactTarget, targetChip, [cueChip.id]);
    
    if (!path1Clear || !path2Clear || !path3Clear) return null;
    
    const distance = Math.hypot(firstContactTarget.x - cueChip.x, firstContactTarget.y - cueChip.y);
    const lineToTargetCenterAngle = Math.atan2(firstContactTarget.y - cueChip.y, firstContactTarget.x - cueChip.x);
    const cutAngle = shotAngle - lineToTargetCenterAngle;
    
    const anglePenalty = (Math.abs(cutAngle) / (Math.PI / 2)) * 0.7;
    const distancePenalty = (distance / canvas.width) * 0.5;
    let probability = 1.0 - distancePenalty - anglePenalty;
    if (isCombination) probability *= 0.6;

    let pocketingScore = 1000;
    if (gameMode.includes('61-ball')) {
        pocketingScore += targetChip.value * 20;
    }

    const power = Math.min(1.2, (distance / (canvas.width * 0.5)) + 0.3);
    const predictedCuePos = predictSimpleCuePos(cueChip, firstContactTarget, shotAngle, power);
    let positionalScore = calculatePositionalScore(predictedCuePos, targetChip.id, allLegalTargets);
    
    let positionalMultiplier = 1.0;
    if (difficulty === 'easy') positionalMultiplier = 0.2; 
    else if (difficulty === 'hard') positionalMultiplier = 0.6;
    
    const totalScore = (pocketingScore + (positionalScore * positionalMultiplier)) * Math.max(0, probability);
    
    return { angle: shotAngle, power, score: totalScore, probability: Math.max(0, probability), target: targetChip, hole: hole, firstContactTarget: firstContactTarget, isCombination };
}

function aiTurn() {
    if (gameState !== 'aiming' || chipsMoving || !chips[0]?.inPlay) return;
    const cueChip = chips[0];
    let allLegalTargets = [], allPocketableChips = [];
    
    if (gameMode.includes('poker')) {
        allLegalTargets = chips.filter(c => c.inPlay && opponentHand.some(card => card.value === c.id));
        allPocketableChips = allLegalTargets;
    } else if (gameMode.includes('61-ball')) {
        const lowestChip = chips.find(c => c.id === lowestChipNumber);
        if (!lowestChip) { setTimeout(handleTurnEnd, 500); return; }
        allLegalTargets = [lowestChip];
        allPocketableChips = chips.filter(c => c.inPlay && c.id !== 0);
    } else {
        if (colorsAssigned && opponentChipsType) allLegalTargets = chips.filter(c => c.inPlay && c.type === opponentChipsType);
        else allLegalTargets = chips.filter(c => c.inPlay && (c.type === 'red' || c.type === 'blue'));
        allPocketableChips = allLegalTargets;
    }

    let simplePots = [];
    let complexShots = [];

    for (const target of allLegalTargets) {
        for (const hole of holes) {
            const evaluation = evaluateShot(cueChip, target, hole, allLegalTargets, difficulty, false);
            if (evaluation) simplePots.push(evaluation);
        }
    }

    if (gameMode.includes('61-ball')) {
        for (const target of allPocketableChips.filter(c => c.id !== allLegalTargets[0].id)) {
            for (const hole of holes) {
                const evaluation = evaluateShot(cueChip, target, hole, allLegalTargets, difficulty, true);
                if (evaluation) complexShots.push(evaluation);
            }
        }
    }

    const allPossibleShots = [...simplePots, ...complexShots];
    if (allPossibleShots.length === 0) {
        let bestShot = findBestDefensiveShot(cueChip, allLegalTargets);
        if (!bestShot) {
             const finalTarget = allLegalTargets[0] || allPocketableChips[0];
             if (finalTarget) {
                 bestShot = { angle: Math.atan2(finalTarget.y - cueChip.y, finalTarget.x - cueChip.x), power: 0.4, probability: 0.5 };
             } else {
                 setTimeout(handleTurnEnd, 500); return;
             }
        }
        animateAiAiming(bestShot.angle, bestShot.power);
        return;
    }

    let bestShot;

    if (difficulty === 'pro') {
        bestShot = allPossibleShots.reduce((best, current) => (current.score > best.score) ? current : best, { score: -Infinity });
    } else {
        const HIGH_PROBABILITY_THRESHOLD = 0.80;
        const decentSimplePots = simplePots.filter(p => p.probability >= HIGH_PROBABILITY_THRESHOLD);

        if (decentSimplePots.length > 0) {
            bestShot = decentSimplePots.reduce((best, current) => (current.score > best.score) ? current : best);
        } else {
            bestShot = allPossibleShots.reduce((best, current) => (current.score > best.score) ? current : best);
        }
    }

    let errorMargin = 0;
    if (difficulty !== 'pro') {
        const shotProbability = bestShot.probability || 1.0;
        if (difficulty === 'hard') {
            if (shotProbability < 0.75) {
                let baseError = (1 - shotProbability) * 0.08;
                const confidenceFactor = 1.0 - (aiConsecutivePots * 0.3);
                errorMargin = baseError * Math.max(0, confidenceFactor);
            }
        } else if (difficulty === 'easy') {
            if (shotProbability < 0.85) errorMargin = (1 - shotProbability) * 0.15;
        }
    }

    if (errorMargin > 0) {
        bestShot.angle += (Math.random() - 0.5) * (errorMargin * 2);
        bestShot.power *= 1 + (Math.random() - 0.5) * errorMargin;
    }
    animateAiAiming(bestShot.angle, bestShot.power);
}

function findBestKickShot(cueChip, legalTargets){let bestKickShot={score:-Infinity};const cushions=[{type:'y',val:0},{type:'y',val:canvas.height},{type:'x',val:0},{type:'x',val:canvas.width}];for(const target of legalTargets){for(const cushion of cushions){let virtualCue=(cushion.type==='y')?{x:cueChip.x,y:cushion.val*2-cueChip.y}:{x:cushion.val*2-cueChip.x,y:cueChip.y};const kickAngle=Math.atan2(target.y-virtualCue.y,target.x-virtualCue.x);const impactPoint=(cushion.type==='y')?{y:cushion.val,x:cueChip.x+(cushion.val-cueChip.y)/Math.tan(kickAngle)}:{x:cushion.val,y:cueChip.y+(cushion.val-cueChip.x)*Math.tan(kickAngle)};const pathToCushionClear=!isPathObstructed(cueChip,impactPoint,[]);const pathFromCushionClear=!isPathObstructed(impactPoint,target,[]);if(pathToCushionClear&&pathFromCushionClear){const power=0.5+Math.random()*0.2;const finalShotAngle=Math.atan2(impactPoint.y-cueChip.y,impactPoint.x-cueChip.x);const score=1000-Math.abs(finalShotAngle-kickAngle);if(score>bestKickShot.score)bestKickShot={score,angle:finalShotAngle,power,probability:0.6};}}}return bestKickShot.score>-Infinity?bestKickShot:null;}
function predictSimpleCuePos(cueChip,targetChip,shotAngle,power){const distance=Math.hypot(targetChip.x-cueChip.x,targetChip.y-cueChip.y);const followDistance=(power*power)*(distance*0.4);return{id:0,x:targetChip.x+Math.cos(shotAngle)*followDistance,y:targetChip.y+Math.sin(shotAngle)*followDistance,radius:cueChip.radius};}
function calculatePositionalScore(predictedCuePos,justPocketedId,allLegalTargets){let nextTargets=[];if(gameMode.includes('poker'))nextTargets=allLegalTargets.filter(t=>t.id!==justPocketedId);else if(gameMode.includes('61-ball')){const remaining=chips.filter(c=>c.inPlay&&c.id!==0&&c.id!==justPocketedId);if(remaining.length>0)nextTargets=[remaining.sort((a,b)=>a.id-b.id)[0]];}else nextTargets=allLegalTargets.filter(t=>t.id!==justPocketedId);if(nextTargets.length===0)return 800;const nextBestTarget=nextTargets.sort((a,b)=>Math.hypot(a.x-predictedCuePos.x,a.y-predictedCuePos.y)-Math.hypot(b.x-predictedCuePos.x,b.y-predictedCuePos.y))[0];let score=600-Math.hypot(nextBestTarget.x-predictedCuePos.x,nextBestTarget.y-predictedCuePos.y);if(isPathObstructed(predictedCuePos,nextBestTarget,[]))score-=400;let bestAngleScore=-200;for(const hole of holes){if(!isPathObstructed(nextBestTarget,hole,[predictedCuePos.id])){const angleToHole=Math.atan2(hole.y-nextBestTarget.y,hole.x-nextBestTarget.x);const shotLine=Math.atan2(nextBestTarget.y-predictedCuePos.y,nextBestTarget.x-predictedCuePos.x);const cutAngle=Math.abs(angleToHole-shotLine);const angleBonus=200*(1-cutAngle/(Math.PI/2));if(angleBonus>bestAngleScore)bestAngleScore=angleBonus;}}score+=bestAngleScore;return score;}
function findBestDefensiveShot(cueChip,legalTargets){if(!legalTargets||legalTargets.length===0)return null;let bestSafety={score:-Infinity,angle:0,power:0};const primaryTarget=legalTargets[0];const opponentNextTarget=primaryTarget;for(let i=0;i < 32;i++){const angleOffset=(Math.random()-0.5)*(Math.PI/4);const shotAngle=Math.atan2(primaryTarget.y-cueChip.y,primaryTarget.x-cueChip.x)+angleOffset;const power=0.25+Math.random()*0.2;const predictedCuePos=predictSimpleCuePos(cueChip,primaryTarget,shotAngle,power);if(holes.some(h=>Math.hypot(h.x-predictedCuePos.x,h.y-predictedCuePos.y)<h.radius*1.2))continue;let safetyScore=0;safetyScore+=Math.hypot(predictedCuePos.x-opponentNextTarget.x,predictedCuePos.y-opponentNextTarget.y);const distToCushion=Math.min(predictedCuePos.x,canvas.width-predictedCuePos.x,predictedCuePos.y,canvas.height-predictedCuePos.y);if(distToCushion<cueChip.radius*3)safetyScore+=300;let blockingBallsCount=0;for(const chip of chips){if(chip.inPlay&&chip.id!==cueChip.id&&chip.id!==opponentNextTarget.id){const distToLine=Math.abs((opponentNextTarget.y-predictedCuePos.y)*chip.x-(opponentNextTarget.x-predictedCuePos.x)*chip.y+opponentNextTarget.x*predictedCuePos.y-opponentNextTarget.y*predictedCuePos.x)/Math.hypot(opponentNextTarget.y-predictedCuePos.y,opponentNextTarget.x-predictedCuePos.x);if(distToLine<chip.radius*2)blockingBallsCount++;}}safetyScore+=blockingBallsCount*400;if(safetyScore>bestSafety.score)bestSafety={score:safetyScore,angle:shotAngle,power:power,probability:0.9};}return bestSafety.score>-Infinity?bestSafety:null;}
// â–¼â–¼â–¼ IPALIT MO ITO SA IYONG BUONG placeCueChipForAI FUNCTION â–¼â–¼â–¼
function placeCueChipForAI() {
    cueBallGuide.style.display = 'none';
    const cueChip = chips[0];
    gameState = 'ai_placing';
    const breakLineX = canvas.width * 0.25;
    let bestPlacement = { score: -Infinity, x: 0, y: 0 };

    for (let i = 0; i < 40; i++) {
        // === ITO ANG INAYOS NA BAHAGI ===
        // Nagdagdag tayo ng espasyo para hindi idikit ng AI ang bola sa banda

        // 1. Itinatakda natin ang "safe zone" para sa paglalagyan ng bola.
        const safeMargin = cueChip.radius + (5 * scale); // Espasyo mula sa kaliwang banda
        const placementWidth = breakLineX - safeMargin - cueChip.radius; // Ang lawak ng area kung saan pwedeng ilapag

        // 2. Kinakalkula ang bagong pwesto sa loob lang ng "safe zone".
        const proposedX = (Math.random() * placementWidth) + safeMargin;
        const proposedY = (Math.random() * (canvas.height - safeMargin * 2)) + safeMargin;
        
        // === DITO NAGTATAPOS ANG PAG-AYOS ===
        
        if (isPositionOccupied(proposedX, proposedY, cueChip)) continue;

        const tempCueChip = { ...cueChip, x: proposedX, y: proposedY };
        let legalTargets = chips.filter(c => c.inPlay && c.id !== 0);
        let bestScoreFromPos = -Infinity;

        for (const target of legalTargets) {
            for (const hole of holes) {
                const evalShot = evaluateShot(tempCueChip, target, hole, legalTargets, 'hard');
                if (evalShot && evalShot.score > bestScoreFromPos) bestScoreFromPos = evalShot.score;
            }
        }
        if (bestScoreFromPos > bestPlacement.score) {
            bestPlacement = { score: bestScoreFromPos, x: proposedX, y: proposedY };
        }
    }

    if (bestPlacement.score > -Infinity) {
        cueChip.x = bestPlacement.x;
        cueChip.y = bestPlacement.y;
    } else {
        cueChip.x = canvas.width * 0.25;
        cueChip.y = canvas.height / 2;
    }
    
    setTimeout(() => {
        canMoveCueBall = false;
        gameState = 'aiming';
        cueStick.visible = true;
        if (cueStickElement) cueStickElement.style.display = 'block';
        setTimeout(aiTurn, 500);
    }, 700);
}

function animateAiAiming(targetAngle,finalPower){const startTime=performance.now();const startAngle=cueStick.angle;const DURATION_ALIGN=800;const DURATION_FEATHER=2500;const DURATION_PAUSE=0;const FEATHER_COUNT=1.5;const FEATHER_DISTANCE=60*scale;const TOTAL_DURATION=DURATION_ALIGN+DURATION_FEATHER+DURATION_PAUSE;function animate(currentTime){const elapsedTime=currentTime-startTime;if(elapsedTime<DURATION_ALIGN){const alignProgress=elapsedTime/DURATION_ALIGN;const easeOut=1-Math.pow(1-alignProgress,4);cueStick.angle=startAngle+(targetAngle-startAngle)*easeOut;cueStick.pullback=0;}else if(elapsedTime<DURATION_ALIGN+DURATION_FEATHER){cueStick.angle=targetAngle;const featherTime=elapsedTime-DURATION_ALIGN;const featherProgress=featherTime/DURATION_FEATHER;cueStick.pullback=Math.abs(Math.sin(featherProgress*Math.PI*(FEATHER_COUNT*2)))*FEATHER_DISTANCE;}else if(elapsedTime<TOTAL_DURATION){cueStick.angle=targetAngle;cueStick.pullback=0;}else{cueStick.angle=targetAngle;shoot(finalPower*40+5);return;}requestAnimationFrame(animate);}requestAnimationFrame(animate);}
function placeChipOnSpot(chipToPlace){
    const spotX = canvas.width * (gameMode.includes('61-ball') ? 0.75 : 0.7);
    const spotY = canvas.height / 2;
    
    let finalX = spotX, finalY = spotY, attempts = 0;
    while(attempts < 100){
        if(!chips.some(c => c.inPlay && c.id !== chipToPlace.id && (finalX - c.x)**2 + (finalY - c.y)**2 < (c.radius + chipToPlace.radius)**2)) break;
        const angle = attempts * 0.5, radius = chipToPlace.radius * 1.2 * Math.sqrt(attempts + 1);
        finalX = spotX + Math.cos(angle) * radius;
        finalY = spotY + Math.sin(angle) * radius;
        attempts++;
    }
    chipToPlace.x = finalX;
    chipToPlace.y = finalY;
}

function createDeck() { deck = []; const suits = ['â™¥', 'â™¦', 'â™£', 'â™ '], ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K']; for (const suit of suits) for (const rank of ranks) { let value = parseInt(rank); if(rank==='A') value=1; else if(rank==='J') value=11; else if(rank==='Q') value=12; else if(rank==='K') value=13; deck.push({ suit, rank, value }); }}
function dealCards() { playerHand = []; opponentHand = []; for (let i = deck.length-1; i > 0; i--) { const j = Math.floor(Math.random()*(i+1)); [deck[i], deck[j]]=[deck[j], deck[i]]; } for (let i = 0; i < 7; i++) { if(deck.length > 0) playerHand.push(deck.pop()); if(deck.length > 0) opponentHand.push(deck.pop()); } originalPlayerHand = [...playerHand]; originalOpponentHand = [...opponentHand]; }

function toggleFullScreen() { if (!document.fullscreenElement) document.documentElement.requestFullscreen().catch(() => showMessage(`Could not activate full-screen mode.`, 2000)); else if (document.exitFullscreen) document.exitFullscreen(); }
async function resetToMenu() {
    playButtonSound();
    
    document.getElementById('chat-toggle-button').style.display = 'none';
    chatContainer.style.display = 'none';
    if (unsubscribeFromChat) unsubscribeFromChat();

    if (isOnlineGame) await leaveOnlineGame(false); 
    
    [winnerModal, gameModeSelect, aiMenu, difficultySelect, onlineMenu, onlineGameSelect, waitingRoom, straightBallInstructions, pokerInstructions, sixtyOneInstructions, confirmExitModal, leaderboardModal].forEach(m => m.style.display = 'none');
    
    gameModeSelect.style.display = 'flex';
    
    if (unsubscribeGameListener) { unsubscribeGameListener(); unsubscribeGameListener = null; }
    
    gameState = 'menu'; 
    isOnlineGame = false; 
    gameId = null; 
    localPlayerId = null;
    
    // Ito ang idinagdag mula sa Hakbang 3
    isAiTakeoverActive = false; 

    updateCardDisplay(); 
    playerInfo.innerHTML = 'You: ?'; 
    opponentInfo.innerHTML = 'Opponent: ?';
    chips = []; 
    draw(); 
    history.pushState({ modal: 'gameModeSelect' }, 'Main Menu', '#main');
}


window.onpopstate = (event) => {
    if (gameState !== 'menu' && gameState !== 'gameover' && !Array.from(document.querySelectorAll('.modal-overlay')).some(m => m.style.display === 'flex')) {
        showExitConfirmation(); history.pushState({ modal: 'game' }, 'Game', '#game'); return;
    }
    const state = event.state || { modal: 'gameModeSelect' };
    const allModals = { gameModeSelect, aiMenu, difficultySelect, straightBallInstructions, pokerInstructions, sixtyOneInstructions, onlineGameSelect, onlineMenu, waitingRoom, winnerModal, confirmExitModal, leaderboardModal };
    Object.values(allModals).forEach(modal => modal.style.display = 'none');
    if (allModals[state.modal]) allModals[state.modal].style.display = 'flex';
    else if (!state.modal || state.modal === 'gameModeSelect') gameModeSelect.style.display = 'flex';
};
function showExitConfirmation() { 
    playButtonSound(); 
    if (gameState !== 'menu' && gameState !== 'gameover' && confirmExitModal.style.display !== 'flex') { 
        confirmExitModal.style.display = 'flex'; 
    } 
}

function setupEventListeners() {

// I-PASTE MO ITONG BUONG CODE BLOCK SA IYONG SCRIPT
   console.log("SUCCESS: Nag-run ang setupEventListeners!"); 

// Event Listeners para sa Shop
shopButton.addEventListener('click', openShop);

shopBackButton.addEventListener('click', () => {
    playButtonSound();
    shopModal.style.display = 'none';
    gameModeSelect.style.display = 'flex';
    history.back();
});

shopTabs.addEventListener('click', (e) => {
    if (e.target.classList.contains('shop-tab-button')) {
        playButtonSound();
        renderShopItems(e.target.dataset.category);
    }
});

// ITO ANG PINAKA-IMPORTANTE PARA SA 'BUY' at 'EQUIP' BUTTONS
shopItemsContainer.addEventListener('click', handleShopAction);

    chatSendBtn.addEventListener('click', function() {
        sendMessage();
    });

    chatInput.addEventListener('keyup', (event) => {
        if (event.key === 'Enter') {
            sendMessage();
        }
    });

    const chatToggleButton = document.getElementById('chat-toggle-button');
    chatToggleButton.addEventListener('click', () => {
        if (chatContainer.style.display === 'flex') {
            chatContainer.style.display = 'none';
        } else {
            chatContainer.style.display = 'flex';
        }
    });

    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('orientationchange', resizeCanvas);
    window.addEventListener('beforeunload', () => { if (isOnlineGame) leaveOnlineGame(true); });
    document.querySelectorAll('.menu-button, .ui-button, .icon-button').forEach(button => button.addEventListener('click', playButtonSound));
    fullscreenButton.addEventListener('click', toggleFullScreen);
    vsAiButton.addEventListener('click', () => { gameModeSelect.style.display = 'none'; aiMenu.style.display = 'flex'; history.pushState({ modal: 'aiMenu' }, 'AI Menu', '#ai'); });
    aiStraightBallButton.addEventListener('click', () => { selectedGameConfig.mode = 'ai-straight-ball'; aiMenu.style.display = 'none'; difficultySelect.style.display = 'flex'; history.pushState({ modal: 'difficultySelect' }, 'Difficulty', '#difficulty'); });
    aiPokerButton.addEventListener('click', () => { selectedGameConfig.mode = 'ai-poker'; aiMenu.style.display = 'none'; difficultySelect.style.display = 'flex'; history.pushState({ modal: 'difficultySelect' }, 'Difficulty', '#difficulty'); });
    ai61Button.addEventListener('click', () => { selectedGameConfig.mode = 'ai-61-ball'; aiMenu.style.display = 'none'; difficultySelect.style.display = 'flex'; history.pushState({ modal: 'difficultySelect' }, 'Difficulty', '#difficulty'); });
    difficultySelect.querySelectorAll('.menu-button[data-difficulty]').forEach(button => {
        button.addEventListener('click', (e) => {
            selectedGameConfig.difficulty = e.target.dataset.difficulty;
            difficultySelect.style.display = 'none';
            if (selectedGameConfig.mode === 'ai-straight-ball') { straightBallInstructions.style.display = 'flex'; history.pushState({ modal: 'straightBallInstructions' }, 'Rules', '#rules'); }
            else if (selectedGameConfig.mode === 'ai-poker') { pokerInstructions.style.display = 'flex'; history.pushState({ modal: 'pokerInstructions' }, 'Rules', '#rules'); }
            else if (selectedGameConfig.mode === 'ai-61-ball') { sixtyOneInstructions.style.display = 'flex'; history.pushState({ modal: 'sixtyOneInstructions' }, 'Rules', '#rules'); }
        });
    });
    [difficultyBackButton, aiBackButton, onlineSelectBackButton, onlineBackButton, cancelGameButton].forEach(btn => btn.addEventListener('click', () => history.back()));
    playStraightBallButton.addEventListener('click', () => startGame(selectedGameConfig.mode, selectedGameConfig.difficulty));
    playPokerButton.addEventListener('click', () => startGame(selectedGameConfig.mode, selectedGameConfig.difficulty));
    play61BallButton.addEventListener('click', () => startGame(selectedGameConfig.mode, selectedGameConfig.difficulty));
    exitButton.addEventListener('click', showExitConfirmation);
    playAgainButton.addEventListener('click', resetToMenu);
    document.getElementById('rematch-button').addEventListener('click', handleRematchRequest);
    confirmExitYes.addEventListener('click', async () => { confirmExitModal.style.display = 'none'; if (gameState === 'gameover' || gameState === 'menu') { resetToMenu(); return; } await endGame("You Forfeited. Opponent Wins!", playerHand, opponentHand); });
    confirmExitCancel.addEventListener('click', () => { playButtonSound(); confirmExitModal.style.display = 'none'; });
    onlineButton.addEventListener('click', () => {
        if (!isAuthReady) { showMessage("Connecting... Please wait.", 2000); return; }
        if (!firebaseInitialized) { showMessage("An internet connection is required for online mode.", 3000); return; }
        gameModeSelect.style.display = 'none'; onlineGameSelect.style.display = 'flex'; history.pushState({ modal: 'onlineGameSelect' }, 'Online', '#online');
    });
    onlinePokerButton.addEventListener('click', () => { selectedOnlineGameType = 'poker'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); });
    onlineStraightBallButton.addEventListener('click', () => { selectedOnlineGameType = 'straight-ball'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); });
    online61Button.addEventListener('click', () => { selectedOnlineGameType = '61-ball'; onlineGameSelect.style.display = 'none'; onlineMenu.style.display = 'flex'; history.pushState({ modal: 'onlineMenu' }, 'Online Menu', '#online-menu'); });
    createGameButton.addEventListener('click', createOnlineGame);
    joinGameButton.addEventListener('click', joinOnlineGame);
    gameIdDisplay.addEventListener('click', () => { navigator.clipboard?.writeText(gameIdDisplay.textContent).then(() => showMessage("Game ID copied!", 1500)); });

    findMatchButton.addEventListener('click', findMatch);
    cancelMatchmakingButton.addEventListener('click', cancelMatchmaking);

    leaderboardButton.addEventListener('click', showLeaderboard);
    leaderboardBackButton.addEventListener('click', () => {
        leaderboardModal.style.display = 'none';
        gameModeSelect.style.display = 'flex';
        history.pushState({ modal: 'gameModeSelect' }, 'Main Menu', '#main');
    });

    [canvas, powerControl, pektusControl, leftArrow, rightArrow].forEach(el => { el.addEventListener('mousedown', handlePointerDown); el.addEventListener('touchstart', handlePointerDown, { passive: false }); });
    window.addEventListener('mouseup', handlePointerUp); window.addEventListener('touchend', handlePointerUp);
    window.addEventListener('mousemove', handlePointerMove); window.addEventListener('touchmove', handlePointerMove, { passive: false });
}
// vvvv IDAGDAG MO ITO SA DULO NG setupEventListeners vvvv

const voiceToggleButton = document.getElementById('voice-toggle-button');
voiceToggleButton.addEventListener('click', toggleAiVoice);

// Kinukuha ang naka-save na setting mula sa localStorage
const savedVoiceSetting = localStorage.getItem('pinoyPoolAiVoice');

// Kung may naka-save, gamitin 'yun. Kung wala, default sa true (ON).
if (savedVoiceSetting !== null) {
    isAiVoiceEnabled = (savedVoiceSetting === 'true');
}

// Ina-update ang icon para tumugma sa setting pagka-load ng laro
updateVoiceButtonIcon();

// ^^^^ HANGGANG DITO ^^^^


function handlePointerDown(e) {
    e.preventDefault();
    const isMyTurn = isOnlineGame ? isMyTurnOnline : playerTurn;
    if (!isMyTurn || (isOnlineGame && isSyncing)) return;
    const targetId = e.currentTarget.id;
    if (gameState === 'moving' && canMoveCueBall && targetId === 'game-canvas') {
        isDraggingCueBall = true;
        cueStick.visible = false;
        ghostHand.style.display = 'block';
        dragGuideText.style.display = 'none';
        updateCueBallPosition(e);
    } else if (gameState === 'aiming') {
        if (targetId === 'game-canvas') {
            isAimingOnCanvas = true;
            updateAimFromCanvas(e);
        } else if (targetId === 'power-control') isPoweringUp = true;
        else if (targetId === 'pektus-control') {
            isDraggingPektusDot = true;
            handlePektusInput(e);
        } else if (targetId === 'left-arrow') isRotatingLeft = true;
        else if (targetId === 'right-arrow') isRotatingRight = true;
    }
}

function handlePointerMove(e) {
    if (isDraggingCueBall) {
        e.preventDefault();
        const clientX = e.touches ? e.touches[0].clientX : e.clientX;
        const clientY = e.touches ? e.touches[0].clientY : e.clientY;
        
        ghostHand.style.left = `${clientX}px`;
        ghostHand.style.top = `${clientY}px`;               
        
        updateCueBallPosition(e);
    } else if (isPoweringUp) {
        e.preventDefault();
        updatePower(e);
    } else if (isAimingOnCanvas) {
        e.preventDefault();
        updateAimFromCanvas(e);
    } else if (isDraggingPektusDot) {
        e.preventDefault();
        handlePektusInput(e);
    }
}

function handlePointerUp() {
    if (isPoweringUp) {
        isPoweringUp = false;
        shoot(cueStick.power * 60 + 2);
    }
    isAimingOnCanvas = false;
    if (isDraggingCueBall) {
        isDraggingCueBall = false;
        ghostHand.style.display = 'none';
        dragGuideText.style.display = 'none';
        // Sa loob ng function handlePointerUp()

    if (!isInvalidPlacement) {
        canMoveCueBall = false;
        gameState = 'aiming';
        cueStick.visible = true;
        if (cueStickElement) cueStickElement.style.display = 'block'; // <--- IDAGDAG ITO
        cueBallGuide.style.display = 'none';
        if (isOnlineGame) {

                const chipsToSend = chips.map(c => ({...c, x: c.x / canvas.width, y: c.y / canvas.height }));
                updateDoc(doc(db, "games", gameId), { canMoveCueBall: false, chips: chipsToSend, liveAimData: null, currentTurnUid: localPlayerUid });
            }
        } else {
            cueStick.visible = true;
        }
    }
    isDraggingPektusDot = false;
    isRotatingLeft = false;
    isRotatingRight = false;
}

function getEventPos(e, relativeTo) { const rect = relativeTo.getBoundingClientRect(); const clientX = e.touches ? e.touches[0].clientX : e.clientX; const clientY = e.touches ? e.touches[0].clientY : e.clientY; return { x: clientX - rect.left, y: clientY - rect.top }; }
function updatePower(e) { const pos = getEventPos(e, powerControl); let p = pos.y / powerControl.clientHeight; cueStick.power = Math.max(0, Math.min(1, p)); powerBar.style.height = `${cueStick.power * 100}%`; cueStick.pullback = cueStick.power * (150 * scale); }
function updateAimFromCanvas(e) { const cueChip = chips[0]; if (!cueChip || !cueChip.inPlay) return; const pos = getEventPos(e, canvas); cueStick.angle = Math.atan2(pos.y - cueChip.y, pos.x - cueChip.x); sendLiveAimData(); }
function updateCueBallPosition(e) { const pos = getEventPos(e, canvas); const cueChip = chips[0]; const breakLineX = canvas.width * 0.25; let proposedX, proposedY; if (isBreakShot) { proposedX = Math.max(cueChip.radius, Math.min(breakLineX - cueChip.radius, pos.x)); proposedY = Math.max(cueChip.radius, Math.min(canvas.height - cueChip.radius, pos.y)); } else { proposedX = Math.max(cueChip.radius, Math.min(canvas.width - cueChip.radius, pos.x)); proposedY = Math.max(cueChip.radius, Math.min(canvas.height - cueChip.radius, pos.y)); } if (!isPositionOccupied(proposedX, proposedY, cueChip)) { cueChip.x = proposedX; cueChip.y = proposedY; isInvalidPlacement = false; sendLiveAimData(); } else isInvalidPlacement = true; }
function handlePektusInput(e) { const rect = pektusControl.getBoundingClientRect(); const x = (e.touches ? e.touches[0].clientX : e.clientX) - rect.left, y = (e.touches ? e.touches[0].clientY : e.clientY) - rect.top; const centerX = rect.width / 2, centerY = rect.height / 2; let dx = x-centerX, dy = y-centerY; const dist = Math.sqrt(dx*dx+dy*dy), maxDist = rect.width/2; if (dist > maxDist) { dx = (dx/dist)*maxDist; dy = (dy/dist)*maxDist; } pektusOffset.x = dx/maxDist; pektusOffset.y = Math.min(0, dy/maxDist); updatePektusUI(); sendLiveAimData(); }
function isPositionOccupied(x, y, draggedChip) { for (const chip of chips) { if (chip.id === draggedChip.id || !chip.inPlay) continue; if ((x-chip.x)**2 + (y-chip.y)**2 < (draggedChip.radius + chip.radius)**2) return true; } return false; }

async function showLeaderboard() {
    leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Loading...</td></tr>';
    gameModeSelect.style.display = 'none';
    leaderboardModal.style.display = 'flex';
    history.pushState({ modal: 'leaderboardModal' }, 'Leaderboard', '#leaderboard');

    try {
        const playersRef = collection(db, "players");
        const q = query(playersRef, orderBy("wins", "desc"), limit(100));
        const querySnapshot = await getDocs(q);
        
        leaderboardBody.innerHTML = '';
        if (querySnapshot.empty) {
             leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">No players yet. Be the first!</td></tr>';
             return;
        }

        let rank = 1;
        querySnapshot.forEach((doc) => {
            const playerData = doc.data();
            const row = document.createElement('tr');
            row.innerHTML = `
                <td style="padding: 8px;">#${rank}</td>
                <td style="padding: 8px;">${playerData.displayName}</td>
                <td style="padding: 8px;">${playerData.wins}</td>
            `;
            leaderboardBody.appendChild(row);
            rank++;
        });
    } catch (error) {
        console.error("Error fetching leaderboard: ", error);
        leaderboardBody.innerHTML = '<tr><td colspan="3" style="text-align: center; padding: 20px;">Could not load leaderboard. Check console for errors.</td></tr>';
        showMessage("Error: You may need to create a Firestore index. Check the console (F12) for a link.", 5000);
    }
}

function initializeFirebase() {
    try {
        onlineButton.textContent = "Connecting..."; onlineButton.disabled = true;
        const firebaseConfig = { apiKey: "AIzaSyD0gZfJxpA_4fO-SEOjX9JNs0v7IzQ0iSc", authDomain: "pinoy-pool-master.firebaseapp.com", projectId: "pinoy-pool-master", storageBucket: "pinoy-pool-master.appspot.com", messagingSenderId: "1003592334290", appId: "1:1003592334290:web:2982cdc8691e8ef7c6260b" };
        const app = initializeApp(firebaseConfig);
        db = getFirestore(app); auth = getAuth(app);
        signInPlayer(); firebaseInitialized = true;
    } catch (error) { console.warn("Firebase failed.", error); firebaseInitialized = false; onlineButton.textContent = "Offline"; onlineButton.disabled = true; }
}
// Palitan mo ang signInPlayer function mo nito
function signInPlayer() {
    onAuthStateChanged(auth, (user) => {
        if (user) { 
            localPlayerUid = user.uid; 
            isAuthReady = true; 
            onlineButton.disabled = false; 
            onlineButton.textContent = "Online Multiplayer"; 
            
            getPlayerProfile(user.uid).then(() => {
                // IDAGDAG MO ANG LINE NA ITO PAGKATAPOS NG getPlayerProfile
                handleDailyLoginBonus(user.uid); 
            });

        } else { 
            // ... (walang babaguhin dito)
        }
    });
}



async function createOnlineGame() {
    if (!isAuthReady || !localPlayerUid) { showMessage("Authenticating... Please wait."); return; }
    onlineMenu.style.display = 'none'; 
    
    // Call resizeCanvas before setupChips to ensure dimensions are correct
    resizeCanvas();
    
    gameMode = `online-${selectedOnlineGameType}`;
    setupChips();
    
    gameId = Math.random().toString(36).substring(2, 7).toUpperCase(); 
    localPlayerId = 'player1'; 
    lastProcessedTurnId = -1; 
    
    const initialChipsToSend = chips.map(c => ({...c, x: c.x/canvas.width, y: c.y/canvas.height }));
    const gameData = { 
        gameId, 
        gameType: selectedOnlineGameType, 
        gameState: 'waiting', 
        turnId: 0, 
        players: { player1: { uid: localPlayerUid, status: 'online' }, player2: null }, 
        chips: initialChipsToSend, 
        currentTurnUid: null, 
        lastShot: null, 
        liveAimData: null, 
        turnInProgress: false, 
        canMoveCueBall: true, 
        isBreakShot: true, 
        winner: null 
    };
    
    if (selectedOnlineGameType === 'poker') {
        createDeck(); 
        dealCards();
        Object.assign(gameData, { deck, player1Hand: playerHand, player2Hand: opponentHand, originalPlayer1Hand: originalPlayerHand, originalPlayer2Hand: originalOpponentHand });
    } else if (selectedOnlineGameType === 'straight-ball') {
        Object.assign(gameData, { colorsAssigned: false, player1ChipsType: null, player2ChipsType: null });
    } else if (selectedOnlineGameType === '61-ball') {
        Object.assign(gameData, { player1_61Score: 0, player2_61Score: 0, lowestChipNumber: 1 });
    }
    
    try {
        await setDoc(doc(db, "games", gameId), gameData);
        gameIdDisplay.textContent = gameId; 
        waitingRoom.style.display = 'flex';
        history.pushState({ modal: 'waitingRoom' }, 'Waiting Room', '#wait');
        listenToGameUpdates(gameId);
    } catch (error) { 
        showMessage("Failed to create game.", 3000); 
        console.error("Firebase setDoc error:", error); 
        onlineMenu.style.display = 'flex'; 
        history.back(); 
    }
}
async function joinOnlineGame() {
    if (!isAuthReady || !localPlayerUid) { showMessage("Authenticating... Please wait."); return; }
    const inputId = gameIdInput.value.trim().toUpperCase(); 
    if (!inputId) { showMessage("Please enter a Game ID."); return; }
    
    const gameDocRef = doc(db, "games", inputId);
    try {
        const docSnap = await getDoc(gameDocRef);
        if (docSnap.exists()) {
            if (docSnap.data().gameState !== 'waiting') { showMessage("Game is full."); return; }
            onlineMenu.style.display = 'none'; 
            showMessage("Joining game...");
            
            const startingPlayerUid = Math.random() < 0.5 ? docSnap.data().players.player1.uid : localPlayerUid;
            await updateDoc(gameDocRef, { 
                'players.player2': { uid: localPlayerUid, status: 'online' }, 
                'gameState': 'playing', 
                'currentTurnUid': startingPlayerUid, 
                'turnId': 1 
            });
            
            gameId = inputId; 
            localPlayerId = 'player2'; 
            listenToGameUpdates(inputId);
        } else {
            showMessage("Game not found.");
        }
    } catch (error) { 
        showMessage("Failed to join game.", 3000); 
    }
}
async function cancelOnlineGame() { 
    if (gameId) { 
        try { 
            await deleteDoc(doc(db, "games", gameId)); 
            gameId = null; 
        } catch (e) { 
            console.error("Error cancelling", e); 
        }
    } 
    resetToMenu(); 
}
async function resetOnlineGameForRematch(gameData) {
    if (unsubscribeGameListener) unsubscribeGameListener();

    gameMode = `online-${gameData.gameType}`;
    resizeCanvas();
    setupChips();

    const newChipsState = chips.map(c => ({...c, x: c.x / canvas.width, y: c.y / canvas.height }));
    const startingPlayerUid = Math.random() < 0.5 ? gameData.players.player1.uid : gameData.players.player2.uid;
    
    const resetData = {
        gameState: 'playing',
        chips: newChipsState,
        currentTurnUid: startingPlayerUid,
        canMoveCueBall: true,
        isBreakShot: true,
        winner: null,
        rematchRequest: null,
        turnId: (gameData.turnId || 0) + 10,
        lastShot: null
    };

    if (gameData.gameType === 'poker') {
        createDeck();
        dealCards();
        Object.assign(resetData, { 
            deck, 
            player1Hand: localPlayerId === 'player1' ? playerHand : opponentHand, 
            player2Hand: localPlayerId === 'player1' ? opponentHand : playerHand,
            originalPlayer1Hand: localPlayerId === 'player1' ? originalPlayerHand : originalOpponentHand,
            originalPlayer2Hand: localPlayerId === 'player1' ? originalOpponentHand : originalPlayerHand,
        });
    } else if (gameData.gameType === '61-ball') {
        Object.assign(resetData, { 
            player1_61Score: 0, 
            player2_61Score: 0, 
            lowestChipNumber: 1 
        });
    } else if (gameData.gameType === 'straight-ball') {
         Object.assign(resetData, { 
            colorsAssigned: false, 
            player1ChipsType: null, 
            player2ChipsType: null 
        });
    }

    try {
        await updateDoc(doc(db, "games", gameId), resetData);
    } catch (error) {
        console.error("Failed to reset game for rematch:", error);
    } finally {
        listenToGameUpdates(gameId);
    }
}

// PALITAN MO ANG IYONG BUONG animateAndApplyShot FUNCTION NITO:
function animateAndApplyShot(shotData) {
    cueStick.angle = shotData.angle;
    cueStick.visible = true; // Pansamantalang ipapakita para sa animation
    if (cueStickElement) cueStickElement.style.display = 'block';
    gameState = 'shooting_animation';
    
    let startTime = null;
    const animationDuration = 100; // Mabilis na animation lang
    const shotPowerNormalized = (shotData.power - 5) / 40;
    const startPullback = shotPowerNormalized * (150 * scale);
    const endPullback = -30 * scale;
    
    function animate(timestamp) {
        if (!startTime) startTime = timestamp;
        const progress = Math.min((timestamp - startTime) / animationDuration, 1);
        cueStick.pullback = startPullback + (endPullback - startPullback) * progress;

        if (progress < 1) {
            requestAnimationFrame(animate);
        } else {
            // === ITO ANG BAGONG DAGDAG PARA ITAGO ANG TAKO NG KALABAN ===
            cueStick.visible = false;
            cueStick.pullback = 0;
            if (cueStickElement) cueStickElement.style.display = 'none';
            
            // Tatawagin na ang physics pagkatapos itago
            applyShot(shotData);
        }
    }
    requestAnimationFrame(animate);
}

function sendLiveAimData() {
    if (!isOnlineGame || !isMyTurnOnline || !gameId || table.width === 0) return;
    const now = Date.now();
    if (now - lastAimUpdateTime < AIM_UPDATE_INTERVAL) return;
    lastAimUpdateTime = now;
    const cueChip = chips.find(c => c.id === 0); if (!cueChip) return;
    const dataToSend = { 
        angle: cueStick.angle, 
        cueBallX: cueChip.x/canvas.width, 
        cueBallY: cueChip.y/canvas.height, 
        pektusX: pektusOffset.x, 
        pektusY: pektusOffset.y, 
        sender: localPlayerUid 
    };
    updateDoc(doc(db, "games", gameId), { liveAimData: dataToSend }).catch(() => {});
}

function listenToGameUpdates(gameId) {
    let lastShotTimestamp = 0;
    setupChatListener(gameId);
    unsubscribeGameListener = onSnapshot(doc(db, "games", gameId), (doc) => {
        if (!doc.exists()) {
            if (gameState !== 'menu' && gameState !== 'gameover') {
                showMessage("Game ended by host.", 3000);
                resetToMenu();
            }
            return;
        }
        const gameData = doc.data();
        if (!gameData) return;

        if (gameData.lastShot && gameData.lastShot.timestamp > lastShotTimestamp && !chipsMoving) {
            lastShotTimestamp = gameData.lastShot.timestamp;
            animateAndApplyShot(gameData.lastShot);
        }
        
        if (gameData.gameState === 'finished' && gameData.rematchRequest) {
            const players = Object.keys(gameData.players).filter(p => gameData.players[p] !== null);
            
            if (players.length === 2) {
                const playerUIDs = players.map(p => gameData.players[p].uid);
                
                const player1_uid = playerUIDs[0];
                const player2_uid = playerUIDs[1];

                const iWantRematch = gameData.rematchRequest[localPlayerUid];
                const opponentUid = localPlayerUid === player1_uid ? player2_uid : player1_uid;
                const opponentWantsRematch = gameData.rematchRequest[opponentUid];

                const rematchButton = document.getElementById('rematch-button');

                if (iWantRematch && opponentWantsRematch) {
                    if (localPlayerId === 'player2') {
                        resetOnlineGameForRematch(gameData);
                    }
                } else if (opponentWantsRematch && !iWantRematch) {
                    rematchButton.textContent = 'Accept Rematch';
                }
            }
        }
        
        syncGameState(gameData);
    });
}

// â–¼â–¼â–¼ IPALIT MO ITO SA IYONG BUONG syncGameState FUNCTION â–¼â–¼â–¼
function syncGameState(data) {
    if (isSyncing || !data) return;
    isSyncing = true;

    let opponentId = null;
    let opponentStatus = null;
    if (localPlayerId && data.players) {
        opponentId = localPlayerId === 'player1' ? 'player2' : 'player1';
        if (data.players[opponentId]) {
            opponentStatus = data.players[opponentId].status;
        }
    }

    if (data.gameState === 'playing' && gameState !== 'playing') {
        gameState = 'playing'; 
        isOnlineGame = true;
        gameMode = `online-${data.gameType}`;
        lastProcessedTurnId = -1;
        
        winnerModal.style.display = 'none';
        waitingRoom.style.display = 'none';
        onlineMenu.style.display = 'none';
        gameModeSelect.style.display = 'none';
        history.pushState({ modal: 'game' }, 'Game', '#game');
        
        if (canvas.width === 0) resizeCanvas();

        if (data.chips) {
            chips = data.chips.map(remoteChip => ({
                ...remoteChip,
                x: remoteChip.x * canvas.width,
                y: remoteChip.y * canvas.height,
                radius: (remoteChip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS) * scale
            }));
        }
        if (data.gameType === 'poker') {
            deck = data.deck || [];
            playerHand = (localPlayerId === 'player1') ? data.player1Hand : data.player2Hand;
            opponentHand = (localPlayerId === 'player1') ? data.player2Hand : data.player1Hand;
        }
    }

    if (data.gameState === 'finished' && gameState !== 'gameover') {
        endGame(data.winner === localPlayerUid ? 'You Win!' : 'You Lose!', data.player1Hand, data.player2Hand);
        isSyncing = false;
        return;
    }

    if (gameState === 'playing') {
        if (opponentStatus === 'disconnected' && !isAiTakeoverActive) {
            isAiTakeoverActive = true;
            showMessage("Opponent disconnected. AI will take over.", 4000);
        } else if (opponentStatus === 'online' && isAiTakeoverActive) {
            isAiTakeoverActive = false;
            showMessage("Opponent has reconnected!", 4000);
        }

        isMyTurnOnline = (data.currentTurnUid === localPlayerUid);

        if (!isMyTurnOnline && data.liveAimData && data.liveAimData.sender !== localPlayerUid) {
            cueStick.visible = true;
            if (cueStickElement) cueStickElement.style.display = 'block';
            const liveAim = data.liveAimData;
            const cueChip = chips.find(c => c.id === 0);
            if (data.canMoveCueBall && cueChip) {
                cueChip.x = liveAim.cueBallX * canvas.width;
                cueChip.y = liveAim.cueBallY * canvas.height;
            }
            cueStick.angle = liveAim.angle;
            cueStick.pullback = liveAim.pullback || 0;
            pektusOffset.x = liveAim.pektusX || 0;
            pektusOffset.y = liveAim.pektusY || 0;
            updatePektusUI();
        }

        if (data.turnId > lastProcessedTurnId) {
            lastProcessedTurnId = data.turnId;
            chipsMoving = false;
            
            if (data.chips && canvas.width > 0) {
                chips = data.chips.map(remoteChip => ({
                     ...remoteChip,
                     x: remoteChip.x * canvas.width,
                     y: remoteChip.y * canvas.height,
                     radius: (remoteChip.id === 0 ? CUE_BALL_RADIUS : BALL_RADIUS) * scale
                }));
            }
            
            canMoveCueBall = data.canMoveCueBall;
            isBreakShot = data.isBreakShot;
            updateCardDisplay();
            updateInfoBox();
            
            const message = data.isBreakShot ? (isMyTurnOnline ? "You break!" : "Opponent's break!") : (isMyTurnOnline ? "Your turn" : "Opponent's turn");
            if (!canMoveCueBall) showMessage(message, 2000);
        }

        if (isMyTurnOnline) {
            gameState = canMoveCueBall ? 'moving' : 'aiming';

            // ================== SIMULA NG BAGONG AYOS ==================
            // Kung turn mo na para mag-aim, siguraduhing nakikita ang tako mo.
            if (gameState === 'aiming') {
                cueStick.visible = true;
                if (cueStickElement) cueStickElement.style.display = 'block';
            }
            // =================== DULO NG BAGONG AYOS ===================

            if (canMoveCueBall && !isDraggingCueBall) {
                dragGuideText.style.display = 'block';
            } else {
                dragGuideText.style.display = 'none';
            }
        } else {
            gameState = 'aiming';
            dragGuideText.style.display = 'none';
        }

        if (isAiTakeoverActive && !isMyTurnOnline && !chipsMoving && !data.turnInProgress) {
            showMessage("AI is playing for your opponent...", 2000);
            setTimeout(() => {
                if (isAiTakeoverActive && !isMyTurnOnline && !chipsMoving) aiTurn();
            }, 1500);
        }
    }
    isSyncing = false;
}





function updateCardDisplay() {
    if (gameMode.includes('poker')) {
        cardHandContainer.style.display = 'flex'; 
        cardHandContainer.innerHTML = ''; 
        let currentHand = playerHand; 
        if (!currentHand) return;
        currentHand.forEach(card => {
            const cardDiv = document.createElement('div'); 
            cardDiv.className = 'card';
            const rankSpan = document.createElement('span'); 
            rankSpan.className = 'card-rank'; 
            rankSpan.textContent = card.rank;
            const suitSpan = document.createElement('span'); 
            suitSpan.className = 'card-suit'; 
            suitSpan.textContent = card.suit;
            if (card.suit === 'â™¥' || card.suit === 'â™¦') { 
                rankSpan.style.color = '#ff5555'; 
                suitSpan.style.color = '#ff5555'; 
            } else { 
                rankSpan.style.color = 'white'; 
                suitSpan.style.color = 'white'; 
            }
            cardDiv.appendChild(rankSpan); 
            cardDiv.appendChild(suitSpan); 
            cardHandContainer.appendChild(cardDiv);
        });
    } else {
        cardHandContainer.style.display = 'none';
    }
    updateInfoBox();
}

function updateInfoBox() {
    const player1Name = 'You', player2Name = 'Opponent';
    if (gameMode.includes('poker')) { 
        playerInfo.innerHTML = `${player1Name}: <span style="color: #FFD700;">${playerHand?.length || 0} cards</span>`; 
        opponentInfo.innerHTML = `${player2Name}: <span style="color: #FFD700;">${opponentHand?.length || 0} cards</span>`; 
    } else if (gameMode.includes('straight-ball')) {
        const vibrantRed = '#ff6b6b', vibrantBlue = '#54a0ff';
        const myColorName = playerChipsType ? playerChipsType.toUpperCase() : '?';
        const theirColorName = opponentChipsType ? opponentChipsType.toUpperCase() : '?';
        const myDisplayColor = playerChipsType === 'red' ? vibrantRed : (playerChipsType === 'blue' ? vibrantBlue : '#FFD700');
        const theirDisplayColor = opponentChipsType === 'red' ? vibrantRed : (opponentChipsType === 'blue' ? vibrantBlue : '#FFD700');
        playerInfo.innerHTML = `${player1Name}: <span style="color: ${myDisplayColor};">${myColorName}</span>`; 
        opponentInfo.innerHTML = `${player2Name}: <span style="color: ${theirDisplayColor};">${theirColorName}</span>`;
    } else if (gameMode.includes('61-ball')) {
        playerInfo.innerHTML = `${player1Name}: <span style="color: #FFD700; font-weight: bold;">${player61Score} pts</span>`;
        opponentInfo.innerHTML = `${player2Name}: <span style="color: #FFD700; font-weight: bold;">${opponent61Score} pts</span>`;
        if(lowestChipNumber > 0 && gameState === 'aiming') {
            cueBallGuide.innerHTML = `Target: Chip #${lowestChipNumber}`;
            cueBallGuide.style.display = 'block';
        } else {
            cueBallGuide.style.display = 'none';
        }
    }
}

function resetPektus() { 
    pektusOffset = { x: 0, y: 0 }; 
    updatePektusUI(); 
}

function updatePektusUI() { 
    const controlSize = pektusControl.offsetWidth;
    if (controlSize === 0) return; // Prevent errors if not visible
    const dotSize = pektusDot.offsetWidth;
    const maxOffset = (controlSize / 2) - (dotSize / 2);
    const dotX = (pektusOffset.x * maxOffset) + (controlSize / 2);
    const dotY = (pektusOffset.y * maxOffset) + (controlSize / 2);
    pektusDot.style.left = `${dotX}px`; 
    pektusDot.style.top = `${dotY}px`; 
}

async function leaveOnlineGame(isForfeit) {
    if (!isOnlineGame || !gameId || !localPlayerId) return;
    const gameDocRef = doc(db, "games", gameId);
    try {
        const docSnap = await getDoc(gameDocRef);
        if (docSnap.exists() && docSnap.data().gameState !== 'finished') {
            const opponentId = localPlayerId === 'player1' ? 'player2' : 'player1';
            const winnerUid = docSnap.data().players[opponentId]?.uid;
            if (isForfeit && winnerUid) {
                await updateDoc(gameDocRef, { 
                    gameState: 'finished', 
                    winner: winnerUid, 
                    [`players.${localPlayerId}.status`]: 'disconnected' 
                });
            } else {
                await updateDoc(gameDocRef, { 
                    [`players.${localPlayerId}.status`]: 'disconnected' 
                });
            }
        }
    } catch (error) { 
        console.error("Error leaving/forfeiting game:", error); 
    }
}
// =================== ITO ANG IPALIT MO (DALAWANG BUONG FUNCTION) ===================

/**
 * Function #1: Ito ang kumukuha ng random na sasabihin ng AI.
 */
function getAiChatMessage(event, lang = 'tl') {
    const messages = aiChatter[lang]?.[event];
    if (!messages || messages.length === 0) {
        return ""; // Walang sasabihin kung walang mahanap na message
    }
    // Random na pipili ng isang message mula sa listahan
    return messages[Math.floor(Math.random() * messages.length)];
}

// =================== ITO NA ANG FINAL VERSION NG aiDisplayMessage ===================

function aiDisplayMessage(message) {
    if (message === "") return;

    // --- PART 1: PAGPAPAKITA NG TEXT BUBBLE (Walang pagbabago)---
    const aiMessageBox = document.createElement('div');
    aiMessageBox.style.position = 'absolute';
    aiMessageBox.style.bottom = '80px';
    aiMessageBox.style.right = '20px';
    aiMessageBox.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
    aiMessageBox.style.color = '#00FF00';
    aiMessageBox.style.padding = '8px 15px';
    aiMessageBox.style.borderRadius = '15px';
    aiMessageBox.style.border = '1px solid rgba(0, 255, 0, 0.5)';
    aiMessageBox.style.fontSize = '0.9em';
    aiMessageBox.style.maxWidth = '200px';
    aiMessageBox.style.textAlign = 'center';
    aiMessageBox.style.zIndex = '250';
    aiMessageBox.style.fontFamily = 'monospace';
    aiMessageBox.style.boxShadow = '0 0 10px rgba(0, 255, 0, 0.3)';
    aiMessageBox.textContent = `AI: "${message}"`;
    document.getElementById('game-wrapper').appendChild(aiMessageBox);

    setTimeout(() => {
        if (aiMessageBox) { aiMessageBox.remove(); }
    }, 4000);

    // === PART 2: FINAL VOICE LOGIC (WITH TOGGLE and FILIPINO VOICE SEARCH) ===
    if (isAiVoiceEnabled) { 
        if ('speechSynthesis' in window) {
            try {
                const utterance = new SpeechSynthesisUtterance(message);

                // Gagamitin natin ang stable na setTimeout para sa mobile
                setTimeout(() => {
                    // Ika-cancel muna natin ang anumang sinasabi para iwas-stuck sa mobile
                    window.speechSynthesis.cancel(); 

                    // Ngayon, hahanapin na ulit natin ang Filipino voice
                    const voices = window.speechSynthesis.getVoices();
                    const filipinoVoice = voices.find(voice => voice.lang === 'fil-PH');
                    if (filipinoVoice) {
                        utterance.voice = filipinoVoice; // Gagamitin ang Filipino voice kung available
                    }

                    utterance.pitch = 0.8;
                    utterance.rate = 1.1;

                    window.speechSynthesis.speak(utterance);
                }, 100); 

            } catch (error) {
                console.error("AI Voice Error:", error);
            }
        }
    }
}
// =================== HANGGANG DITO ===================

// =================== HAKBANG 3 C: IDAGDAG ANG DALAWANG FUNCTION NA ITO ===================

function toggleAiVoice() {
    // Binabaligtad ang value (kung true, magiging false; kung false, magiging true)
    isAiVoiceEnabled = !isAiVoiceEnabled;

    // Isine-save ang bagong setting sa localStorage para matandaan
    localStorage.setItem('pinoyPoolAiVoice', isAiVoiceEnabled);

    // Pinapatigil ang anumang kasalukuyang sinasabi kung pinatay ang sound
    if (!isAiVoiceEnabled) {
        window.speechSynthesis.cancel();
    }

    // Ina-update ang icon na nakikita
    updateVoiceButtonIcon();
}

function updateVoiceButtonIcon() {
    const voiceOnIcon = document.getElementById('voice-on-icon');
    const voiceOffIcon = document.getElementById('voice-off-icon');
    if (isAiVoiceEnabled) {
        voiceOnIcon.style.display = 'block';
        voiceOffIcon.style.display = 'none';
    } else {
        voiceOnIcon.style.display = 'none';
        voiceOffIcon.style.display = 'block';
    }
}

// =================== HANGGANG DITO ===================


init();

Â  Â  </script>
</body>
</html>
